= Vert.x Circuit Breaker

Vert.x Circuit Breaker 是Vert.x熔断模式的实现。

它用来追踪故障，当失败次数达到阈值时触发熔断，并且可选择性提供失败回调，以保证服务可用或长时间等待。

支持以下故障:

* 使用 `link:../../apidocs/io/vertx/core/Future.html[Future]` 时失败
* 代码里主动抛出异常
* 没有完成的``Future``,例如:超时.

熔断器要旨是保护 Vert.x 的 非阻塞 和 异步 的行为，以便受益于Vert.x 执行模型。

== 准备工作

使用Vert.x Circuit Breaker之前，你必须在你得项目当中添加依赖。

* Maven (在 `pom.xml` 文件中):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-circuit-breaker</artifactId>
 <version>4.0.0</version>
</dependency>
----

* Gradle (在 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-circuit-breaker:4.0.0'
----

== 开始 The circuit breaker 之旅

为了使用熔断器我们需要以下的步骤：

* 创建一个熔断器，并配置成你所需要的超时，最大故障次数等参数

* 使用熔断器执行代码

**重要！！！**: 熔断器应该是稳定的单例，而不是每次使用就重新创建它。

例子:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions()
        .setMaxFailures(5) // 最大失败数
        .setTimeout(2000) // 超时时间
        .setFallbackOnFailure(true) // 失败后是否调用回调
        .setResetTimeout(10000) // 从，状态重置时间
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.execute(promise -> {
  // 在熔断器中执行的代码
  // 这里的代码可以成功或者失败，
  // 如果future在这里被标记为失败，熔断器将自增失败数
}).onComplete(ar -> {
  // 处理结果.
});
----

The executed block receives a `link:../../apidocs/io/vertx/core/Future.html[Future]` object as parameter, to denote the
success or failure of the operation as well as the result.For example in the following example, the result is the
output of a REST endpoint invocation:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.<String>execute(promise -> {
  vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
    .compose(req -> req
      .send()
      .compose(resp -> {
        if (resp.statusCode() != 200) {
          return Future.failedFuture("HTTP error");
        } else {
          return resp.body().map(Buffer::toString);
        }
      })).onComplete(promise);
}).onComplete(ar -> {
  // Do something with the result
});
----

The result of the operation is provided using the:

* returned `link:../../apidocs/io/vertx/core/Future.html[Future]` when calling `execute` methods
* provided `link:../../apidocs/io/vertx/core/Future.html[Future]` when calling the `executeAndReport` methods

Optionally, you can provide a fallback which is executed when the circuit is open:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.executeWithFallback(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
      }, v -> {
      // Executed when the circuit is opened
      return "Hello";
    })
    .onComplete(ar -> {
      // Do something with the result
    });
----

The fallback is called whenever the circuit is open, or if the
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#isFallbackOnFailure--[isFallbackOnFailure]` is enabled.When a fallback is
set, the result is using the output of the fallback function.The fallback function takes as parameter a
`link:../../apidocs/java/lang/Throwable.html[Throwable]` object and returns an object of the expected type.

The fallback can also be set on the `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html[CircuitBreaker]` object directly:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
).fallback(v -> {
  // Executed when the circuit is opened.
  return "hello";
});

breaker.<String>execute(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
    });
----

== Retries

You can also specify how often the circuit breaker should try your code before failing with
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setMaxRetries-int-[setMaxRetries]`.
If you set this to something higher than 0 your code gets executed several times before finally failing
in the last execution. If the code succeeded in one of the retries your handler gets notified and any
retries left are skipped. Retries are only supported when the circuit is closed.

Notice that if you set `maxRetries` to 2 for instance, your operation may be called 3 times: the initial attempt
and 2 retries.

By default the timeout between retries is set to 0 which means that retries will be executed one after another without
any delay. This, however, will result in increased load on the called service and may delay it's recovery.
In order to mitigate this problem it is recommended to execute retries with delays. `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#retryPolicy-java.util.function.Function-[retryPolicy]`
method can be used to specify retry policy. Retry policy is a function which receives retry count as single argument
and returns timeout in milliseconds before retry is executed and allows to implement a more complex policy, e.g.
exponential backoff with jitter. Below is an example of retry timeout which grows linearly with each retry count:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
  new CircuitBreakerOptions().setMaxFailures(5).setMaxRetries(5).setTimeout(2000)
).openHandler(v -> {
  System.out.println("Circuit opened");
}).closeHandler(v -> {
  System.out.println("Circuit closed");
}).retryPolicy(retryCount -> retryCount * 100L);

breaker.<String>execute(
  promise -> {
    vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
      .compose(req -> req
        .send()
        .compose(resp -> {
          if (resp.statusCode() != 200) {
            return Future.failedFuture("HTTP error");
          } else {
            return resp.body().map(Buffer::toString);
          }
        })).onComplete(promise);
  });
----

== Callbacks

You can also configures callbacks invoked when the circuit is opened or closed:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
).openHandler(v -> {
  System.out.println("Circuit opened");
}).closeHandler(v -> {
  System.out.println("Circuit closed");
});

breaker.<String>execute(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
    });
----

You can also be notified when the circuit breaker decides to attempt to reset (half-open state). You can register
such a callback with `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#halfOpenHandler-io.vertx.core.Handler-[halfOpenHandler]`.

== Event bus notification

Every time the circuit state changes, an event is published on the event bus. The address on which the events are
sent is configurable with
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setNotificationAddress-java.lang.String-[setNotificationAddress]`. If `null` is
passed to this method, the notifications are disabled. By default, the used address is `vertx.circuit-breaker`.

Each event contains a Json Object with:

* `state` : the new circuit breaker state (`OPEN`, `CLOSED`, `HALF_OPEN`)
* `name` : the name of the circuit breaker
* `failures` : the number of failures
* `node` : the identifier of the node (`local` if Vert.x is not running in cluster mode)

== The half-open state

When the circuit is "open", calls to the circuit breaker fail immediately, without any attempt to execute the real
operation. After a suitable amount of time (configured from
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setResetTimeout-long-[setResetTimeout]`, the circuit breaker decides that the
operation has a chance of succeeding, so it goes into the `half-open` state. In this state, the next call to the
circuit breaker is allowed to execute the dangerous operation. Should the call succeed, the circuit breaker resets
and returns to the `closed` state, ready for more routine operation. If this trial call fails, however, the circuit
breaker returns to the `open` state until another timeout elapses.

== Reported exceptions

The fallback receives a:

* `link:../../apidocs/io/vertx/circuitbreaker/OpenCircuitException.html[OpenCircuitException]` when the circuit breaker is opened
* `link:../../apidocs/io/vertx/circuitbreaker/TimeoutException.html[TimeoutException]` when the operation timed out

== Pushing circuit breaker metrics to the Hystrix Dashboard

Netflix Hystrix comes with a dashboard to present the current state of the circuit breakers. The Vert.x circuit
breakers can publish their metrics in order to be consumed by this Hystrix Dashboard. The Hystrix dashboard requires
a SSE stream sending the metrics. This stream is provided by the
`link:../../apidocs/io/vertx/circuitbreaker/HystrixMetricHandler.html[HystrixMetricHandler]` Vert.x Web Handler:


[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx);
CircuitBreaker breaker2 = CircuitBreaker.create("my-second-circuit-breaker", vertx);

// Create a Vert.x Web router
Router router = Router.router(vertx);
// Register the metric handler
router.get("/hystrix-metrics").handler(HystrixMetricHandler.create(vertx));

// Create the HTTP server using the router to dispatch the requests
vertx.createHttpServer()
  .requestHandler(router)
  .listen(8080);
----

In the Hystrix Dashboard, configure the stream url like: `http://localhost:8080/metrics`. The dashboard now consumes
the metrics from the Vert.x circuit breakers.

Notice that the metrics are collected by the Vert.x Web handler using the event bus notifications. If you don't use
the default notification address, you need to pass it when creating the metrics handler.

== Using Netflix Hystrix

https://github.com/Netflix/Hystrix[Hystrix] provides an implementation of the circuit breaker pattern. You can use
Hystrix with Vert.x instead of this circuit breaker or in combination of. This section describes the tricks
to use Hystrix in a vert.x application.

First you would need to add the Hystrix dependency to your classpath or build descriptor. Refer to the Hystrix
page for details. Then, you need to isolate the "protected" call in a `Command`. Once you have your command, you
can execute it:

[source, java]
----
HystrixCommand<String> someCommand = getSomeCommandInstance();
String result = someCommand.execute();
----

However, the command execution is blocking, so have to call the command execution either in an `executeBlocking`
block or in a worker verticle:

[source, java]
----
HystrixCommand<String> someCommand = getSomeCommandInstance();
vertx.<String>executeBlocking(
future -> future.complete(someCommand.execute()),
ar -> {
// back on the event loop
String result = ar.result();
}
);
----

If you use the async support of Hystrix, be careful that callbacks are not called in a vert.x thread and you have
to keep a reference on the context before the execution (with `link:../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--[getOrCreateContext]`,
and in the callback, switch back to the event loop using
`link:../../apidocs/io/vertx/core/Vertx.html#runOnContext-io.vertx.core.Handler-[runOnContext]`. Without this, you are loosing the Vert.x
concurrency model and have to manage the synchronization and ordering yourself:

[source, java]
----
vertx.runOnContext(v -> {
Context context = vertx.getOrCreateContext();
HystrixCommand<String> command = getSomeCommandInstance();
command.observe().subscribe(result -> {
context.runOnContext(v2 -> {
// Back on context (event loop or worker)
String r = result;
});
});
});
----
