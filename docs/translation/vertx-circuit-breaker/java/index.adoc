= Vert.x Circuit Breaker

Circuit Breaker 是Vert.x熔断模式的实现。
它用来追踪故障，当失败次数达到阈值时触发熔断，并且可选择性提供失败回调。

支持以下故障:

* 在 `link:../../apidocs/io/vertx/core/Future.html[Future]` 内记录的失败
* 代码里主动抛出异常
* 没有完成的 `Future`（即超时）。

熔断器要旨是保障其操作是非阻塞且异步的，以便受益于Vert.x 执行模型。

[[_using_the_vert_x_circuit_breaker]]
== 准备工作

使用Vert.x Circuit Breaker之前，你必须在你得项目当中添加 _依赖_ :

* Maven（在您的 `pom.xml` 文件中）：

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-circuit-breaker</artifactId>
 <version>4.0.0</version>
</dependency>
----

* Gradle（在您的 `build.gradle` 文件中）：

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-circuit-breaker:4.0.0'
----

[[_using_the_circuit_breaker]]
== 使用熔断器

使用熔断器需要按以下步骤进行：

1. 创建一个熔断器，并配置成你所需要的超时，最大故障次数等参数

2. 使用熔断器执行代码

**重要！！！** 熔断器应该是稳定的单例，而不是每次使用就重新创建它。推荐将该单例存放在某个领域中。

例子:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions()
        .setMaxFailures(5) // 最大失败数
        .setTimeout(2000) // 超时时间
        .setFallbackOnFailure(true) // 失败后是否调用回调
        .setResetTimeout(10000) // 从，状态重置时间
);

// ---
// 将熔断器存放在某个领域中并像如下方式使用
// ---

breaker.execute(promise -> {
  // 在熔断器中执行的代码
  // 这里的代码可以成功或者失败，
  // 如果该 promise 在这里被标记为失败，熔断器将自增失败数
}).onComplete(ar -> {
  // 处理结果.
});
----

execute代码块接收 `link:../../apidocs/io/vertx/core/Future.html[Future]` 
对象参数，以标识该操作以及结果的失败或成功。
例如:在下面的例子中，对应的结果就是REST调用的输出：

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.<String>execute(promise -> {
  vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
    .compose(req -> req
      .send()
      .compose(resp -> {
        if (resp.statusCode() != 200) {
          return Future.failedFuture("HTTP error");
        } else {
          return resp.body().map(Buffer::toString);
        }
      })).onComplete(promise);
}).onComplete(ar -> {
  // 处理结果
});
----

操作的结果以下面的方式提供:

* 调用 `execute` 方法时,返回 `link:../../apidocs/io/vertx/core/Future.html[Future]`
* 调用 `executeAndReport` 方法时,提供 `link:../../apidocs/io/vertx/core/Future.html[Future]` 参数

也可以增加一个可选参数,用于熔断时进行失败回调(fallback):

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
);

// ---
// 熔断器会临时存储该次运行结果,用于熔断判断
// ---

breaker.executeWithFallback(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
      }, v -> {
      // 当熔断器熔断时,返回Hello
      return "Hello";
    })
    .onComplete(ar -> {
        // 处理结果
    });
----

每当熔断器熔断的时候,都会调用失败回调(fallback), 也可以调用
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#isFallbackOnFailure--[isFallbackOnFailure]` 方法开启(关闭)失败回调.
调用失败回调的时候,其结果会以 `link:../../apidocs/java/lang/Throwable.html[Throwable]` 为参数返回预期对象.

通过 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html[CircuitBreaker]` 设置全局的失败回调方法:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
).fallback(v -> {
  //  当熔断器熔断时将调用此处代码
  return "hello";
});

breaker.<String>execute(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
    });
----

[[_retries]]
== 重试

还可以通过 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setMaxRetries-int-[setMaxRetries]`.
设置重试次数,如果你设置大于0的数值，失败的情况下会重试，直到重试次数等于该数值，如果其中一次重试成功，
那么会跳过剩下的重试。

*注意* 如果你设置最大重试次数 `maxRetries` 为2, 那么你得代码在失败的情况将会执行3次，三次分别为初次请求，2次重试。

在默认情况下超时时间(timeout)和重试次数(retries)为0,那么将会无延时的一直请求下去,这会导致调用服务负载增加
导致服务恢复时间延长。所以为了减少这种情况设置延时和重试次数。
方法 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#retryPolicy-java.util.function.Function-[retryPolicy]`
用于设置重试策略。 该方法接收一个Function<Integer,Long>的函数体(传入参数为重试次数,返回具体超时时间,单位:毫秒),
允许用户定制更加复杂的延时策略(例如:带抖动的延时补偿)

下面是设置了重试策略的例子，重试超时时间与重试时间呈线指数增长。

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
  new CircuitBreakerOptions().setMaxFailures(5).setMaxRetries(5).setTimeout(2000)
).openHandler(v -> {
  System.out.println("Circuit opened");
}).closeHandler(v -> {
  System.out.println("Circuit closed");
}).retryPolicy(retryCount -> retryCount * 100L);

breaker.<String>execute(
  promise -> {
    vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
      .compose(req -> req
        .send()
        .compose(resp -> {
          if (resp.statusCode() != 200) {
            return Future.failedFuture("HTTP error");
          } else {
            return resp.body().map(Buffer::toString);
          }
        })).onComplete(promise);
  });
----

[[_callbacks]]
== 回调

你可以配置熔断开路(OPEN)/闭路(CLOSE)时回调。

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
).openHandler(v -> {
  System.out.println("Circuit opened");
}).closeHandler(v -> {
  System.out.println("Circuit closed");
});

breaker.<String>execute(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
    });
----

当熔断器决定尝试复位的时候（ half-open 状态），我们也可以注册 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#halfOpenHandler-io.vertx.core.Handler-[halfOpenHandler]` 的回调从而得到回调通知。

[[_event_bus_notification]]
== 事件总线通知

每当熔断器发生状态改变的时候,熔断器都会在事件总线上推送通知，总线通默认地址为：`vertx.circuit-breaker`。
当然这个也是可以配置的，调用方法
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setNotificationAddress-java.lang.String-[setNotificationAddress]`. If `null` is
你可以设置总线通知地址。如果设置为 `null` 那么总线通知将被禁用。

每个总线通知都会包含一个 Json Object对象，该对象包括以下字段：

* `state` : 熔断器最新的状态（`OPEN`, `CLOSED`, `HALF_OPEN`）
* `name` : 熔断器的名称
* `failures` : 错误次数
* `node` : 节点标识 (如果事件总线并非运行在集群模式中，那么该值为：`local`)

[[_the_half_open_state]]
== 半开状态

当熔断器处于开路状态时，对其调用会立即失败，不会执行实际操作。经过适当的时间 (通过
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setResetTimeout-long-[setResetTimeout]` 配置）,
熔断器决定是否恢复状态，此时进入半开启状态（half-open state）。在这种状态下，
允许下一次熔断器的调用实际调用如果成功，熔断器将复位并返回到关闭状态，
回归正常的模式；但是如果这次调用失败，则熔断器返回到熔断状态，直到下次半开状态。

[[_reported_exceptions]]
== 异常

异常状态:

* 当熔断器开路(OPEN)的情况,会抛出 `link:../../apidocs/io/vertx/circuitbreaker/OpenCircuitException.html[OpenCircuitException]` 异常
* 当操作超时的时候,会抛出 `link:../../apidocs/io/vertx/circuitbreaker/TimeoutException.html[TimeoutException]`

[[_pushing_circuit_breaker_metrics_to_the_hystrix_dashboard]]
== 将熔断器指标推送到Hystrix看板（Dashboard）

Netflix Hystrix带有一个看板（dashboard），用于显示熔断器的当前状态。 Vert.x 熔断器可以发布其指标（metric），以供Hystrix 仪表板使用。 Hystrix 仪表板需要一个发送指标的SSE流，
此流由 `link:../../apidocs/io/vertx/circuitbreaker/HystrixMetricHandler.html[HystrixMetricHandler]`
这个 Vert.x Web Handler 提供


[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx);
CircuitBreaker breaker2 = CircuitBreaker.create("my-second-circuit-breaker", vertx);

// 创建 Vert.x Web 路由
Router router = Router.router(vertx);
// 注册指标Handler
router.get("/hystrix-metrics").handler(HystrixMetricHandler.create(vertx));

// / 创建HTTP服务器，并分配路由
vertx.createHttpServer()
  .requestHandler(router)
  .listen(8080);
----

在Hystrix 看板, 配置 stream url 地址,例如: `http://localhost:8080/metrics`. 现在就可以获取Vert.x的熔断器指标了。

*注意*：这些指标量是由 Vert.x Web Handler 使用 Event Bus 事件通知收集。
如您不想使用默认的通知地址，请在创建的时候设置。

[[_using_netflix_hystrix]]
== 使用 Netflix Hystrix

https://github.com/Netflix/Hystrix[Hystrix] 提供了熔断器模式的实现。可以在Vert.x中使用Hystrix提供的熔断器或组合使用。
本节介绍在Vert.x应用程序中使用Hystrix的技巧。

首先，您需要将Hystrix添加到你的依赖中。详细信息请参阅Hystrix页面。然后，您需要使用 Command 隔离“受保护的”调用。
您可以这样执行之：

[source, java]
----
HystrixCommand<String> someCommand = getSomeCommandInstance();
String result = someCommand.execute();
----

但是，代码执行是阻塞的，必须使用 `executeBlocking` 方法去执行，或者在Worker Verticle中调用：

[source, java]
----
HystrixCommand<String> someCommand = getSomeCommandInstance();
vertx.<String>executeBlocking(
future -> future.complete(someCommand.execute()),
ar -> {
// 回到Event Loop线程中
String result = ar.result();
}
);
----

如果你使用了Hystrix异步方法, 对应回调函数是不会在Vert.x的线程中执行的,因此我们必须在执行前保持上下的引用,
（使用 `link:../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--[getOrCreateContext]` 方法），
执行
`link:../../apidocs/io/vertx/core/Vertx.html#runOnContext-io.vertx.core.Handler-[runOnContext]` 方法将当前线程切换回Event Loop线程。
不这样做的话，您将失去Vert.x异步模型的优势，并且必须自行管理线程同步和执行顺序：

[source, java]
----
vertx.runOnContext(v -> {
    Context context = vertx.getOrCreateContext();
    HystrixCommand<String> command = getSomeCommandInstance();
    command.observe().subscribe(result -> {
        context.runOnContext(v2 -> {
            // 回到Vert.x Context下(Event Loop线程或Worker线程)
            String r = result;
        });
    });
});
----
