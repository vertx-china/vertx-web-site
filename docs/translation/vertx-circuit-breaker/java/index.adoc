= Vert.x Circuit Breaker

Vert.x Circuit Breaker 是Vert.x熔断模式的实现。

它用来追踪故障，当失败次数达到阈值时触发熔断，并且可选择性提供失败回调，以保证服务可用或长时间等待。

支持以下故障:

* 使用 `link:../../apidocs/io/vertx/core/Future.html[Future]` 时失败
* 代码里主动抛出异常
* 没有完成的``Future``,例如:超时.

熔断器要旨是保护 Vert.x 的 非阻塞 和 异步 的行为，以便受益于Vert.x 执行模型。

== 准备工作

使用Vert.x Circuit Breaker之前，你必须在你得项目当中添加依赖。

* Maven (在 `pom.xml` 文件中):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-circuit-breaker</artifactId>
 <version>4.0.0</version>
</dependency>
----

* Gradle (在 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-circuit-breaker:4.0.0'
----

== 开始 The circuit breaker 之旅

为了使用熔断器我们需要以下的步骤：

* 创建一个熔断器，并配置成你所需要的超时，最大故障次数等参数

* 使用熔断器执行代码

**重要！！！**: 熔断器应该是稳定的单例，而不是每次使用就重新创建它。

例子:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions()
        .setMaxFailures(5) // 最大失败数
        .setTimeout(2000) // 超时时间
        .setFallbackOnFailure(true) // 失败后是否调用回调
        .setResetTimeout(10000) // 从，状态重置时间
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.execute(promise -> {
  // 在熔断器中执行的代码
  // 这里的代码可以成功或者失败，
  // 如果future在这里被标记为失败，熔断器将自增失败数
}).onComplete(ar -> {
  // 处理结果.
});
----

执行结果以 `link:../../apidocs/io/vertx/core/Future.html[Future]` 对象返回,其 `link:../../apidocs/io/vertx/core/Future.html[Future]` 对象,封装了成功结果集或失败结果集

例如:在下面的例子中，对应的结果就是REST调用的输出：

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.<String>execute(promise -> {
  vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
    .compose(req -> req
      .send()
      .compose(resp -> {
        if (resp.statusCode() != 200) {
          return Future.failedFuture("HTTP error");
        } else {
          return resp.body().map(Buffer::toString);
        }
      })).onComplete(promise);
}).onComplete(ar -> {
  // 处理结果
});
----

操作的结果以下面的方式提供:

* 调用 `execute` 方法时,返回 link:../../apidocs/io/vertx/core/Future.html[Future]`
* 调用 `executeAndReport` 方法时,提供 `link:../../apidocs/io/vertx/core/Future.html[Future]` 参数

也可以增加一个可选参数,用于熔断时进行失败回调(fallback):

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
);

// ---
// 熔断器会临时存储该次运行结果,用于熔断判断
// ---

breaker.executeWithFallback(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
      }, v -> {
      // 当熔断器熔断时,返回Hello
      return "Hello";
    })
    .onComplete(ar -> {
        // 处理结果
    });
----

每当熔断器熔断的时候,都会调用失败回调(fallback), 或者调用
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#isFallbackOnFailure--[isFallbackOnFailure]` 方法用于开启(关闭)失败回调.
调用失败回调的时候,其结果会以 `link:../../apidocs/java/lang/Throwable.html[Throwable]` 为参数返回预期对象.

通过 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html[CircuitBreaker]` 设置全局的失败回调方法:

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
).fallback(v -> {
  //  当熔断器熔断时将调用此处代码
  return "hello";
});

breaker.<String>execute(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
    });
----

== 重试（Retries）

还可以通过 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setMaxRetries-int-[setMaxRetries]`.
设置重试次数,如果你设置大于0的数值,在失败的情况下,会重试到该数值，如果在最后一次执行得到正确的结果，
那么处理结果可以被正确的调用，剩下的重试次数将被跳过

*注意* 如果你设置最大重试次数 `maxRetries` 为2, 那么你得代码在失败的情况将会执行3次，三次分别为初次请求，2次重试次数。

在默认情况下超时时间(timeout)和重试次数(retries)为0,那么将会无延时的一直请求下去,这会导致调用服务负载增加
导致服务恢复时间延长。所以为了减少这种情况设置延时和重试次数。
方法 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#retryPolicy-java.util.function.Function-[retryPolicy]`
用于设置重试策略。 该方法接收一个Function<Integer,Long>的函数体(传入参数为重试次数,返回具体超时时间,单位:毫秒),
允许用户定制更加复杂的延时策略(例如:带抖动的延时补偿)

下面是设置了重试策略的例子，重试超时时间与重试时间呈线指数增长。

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
  new CircuitBreakerOptions().setMaxFailures(5).setMaxRetries(5).setTimeout(2000)
).openHandler(v -> {
  System.out.println("Circuit opened");
}).closeHandler(v -> {
  System.out.println("Circuit closed");
}).retryPolicy(retryCount -> retryCount * 100L);

breaker.<String>execute(
  promise -> {
    vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
      .compose(req -> req
        .send()
        .compose(resp -> {
          if (resp.statusCode() != 200) {
            return Future.failedFuture("HTTP error");
          } else {
            return resp.body().map(Buffer::toString);
          }
        })).onComplete(promise);
  });
----

== 回调（Callbacks）

你可以配置熔断全开(open)/关闭(close)时回调。

[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions().setMaxFailures(5).setTimeout(2000)
).openHandler(v -> {
  System.out.println("Circuit opened");
}).closeHandler(v -> {
  System.out.println("Circuit closed");
});

breaker.<String>execute(
    promise -> {
      vertx.createHttpClient().request(HttpMethod.GET, 8080, "localhost", "/")
        .compose(req -> req
          .send()
          .compose(resp -> {
            if (resp.statusCode() != 200) {
              return Future.failedFuture("HTTP error");
            } else {
              return resp.body().map(Buffer::toString);
            }
          })).onComplete(promise);
    });
----

当熔断器决定尝试复位的时候（ half-open 状态），我们也可以注册 `link:../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#halfOpenHandler-io.vertx.core.Handler-[halfOpenHandler]` 的回调从而得到回调通知。

== Event bus notification(事件总线通知)

每当熔断器发生状态改变的时候,熔断器都会在事件总线上推送通知，总线通默认地址为：`vertx.circuit-breaker`。
当然这个也是可以配置的，调用方法
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setNotificationAddress-java.lang.String-[setNotificationAddress]`. If `null` is
你可以设置总线通知地址。如果设置为 `null` 那么总线通知将被禁用。

每个总线通知都会包含一个 Json Object对象，该对象包括以下字段：

* `state` : 熔断器最新的状态 (`OPEN`, `CLOSED`, `HALF_OPEN`)
* `name` : 熔断器的名称
* `failures` : 错误次数
* `node` : 节点标识 (如果事件总线运行在单节模式，那么该值为：`local`)

== 半开状态（half-open）

When the circuit is "open", calls to the circuit breaker fail immediately, without any attempt to execute the real
operation. After a suitable amount of time (configured from
`link:../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setResetTimeout-long-[setResetTimeout]`, the circuit breaker decides that the
operation has a chance of succeeding, so it goes into the `half-open` state. In this state, the next call to the
circuit breaker is allowed to execute the dangerous operation. Should the call succeed, the circuit breaker resets
and returns to the `closed` state, ready for more routine operation. If this trial call fails, however, the circuit
breaker returns to the `open` state until another timeout elapses.

== Reported exceptions

The fallback receives a:

* `link:../../apidocs/io/vertx/circuitbreaker/OpenCircuitException.html[OpenCircuitException]` when the circuit breaker is opened
* `link:../../apidocs/io/vertx/circuitbreaker/TimeoutException.html[TimeoutException]` when the operation timed out

== Pushing circuit breaker metrics to the Hystrix Dashboard

Netflix Hystrix comes with a dashboard to present the current state of the circuit breakers. The Vert.x circuit
breakers can publish their metrics in order to be consumed by this Hystrix Dashboard. The Hystrix dashboard requires
a SSE stream sending the metrics. This stream is provided by the
`link:../../apidocs/io/vertx/circuitbreaker/HystrixMetricHandler.html[HystrixMetricHandler]` Vert.x Web Handler:


[source,java]
----
CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx);
CircuitBreaker breaker2 = CircuitBreaker.create("my-second-circuit-breaker", vertx);

// Create a Vert.x Web router
Router router = Router.router(vertx);
// Register the metric handler
router.get("/hystrix-metrics").handler(HystrixMetricHandler.create(vertx));

// Create the HTTP server using the router to dispatch the requests
vertx.createHttpServer()
  .requestHandler(router)
  .listen(8080);
----

In the Hystrix Dashboard, configure the stream url like: `http://localhost:8080/metrics`. The dashboard now consumes
the metrics from the Vert.x circuit breakers.

Notice that the metrics are collected by the Vert.x Web handler using the event bus notifications. If you don't use
the default notification address, you need to pass it when creating the metrics handler.

== Using Netflix Hystrix

https://github.com/Netflix/Hystrix[Hystrix] provides an implementation of the circuit breaker pattern. You can use
Hystrix with Vert.x instead of this circuit breaker or in combination of. This section describes the tricks
to use Hystrix in a vert.x application.

First you would need to add the Hystrix dependency to your classpath or build descriptor. Refer to the Hystrix
page for details. Then, you need to isolate the "protected" call in a `Command`. Once you have your command, you
can execute it:

[source, java]
----
HystrixCommand<String> someCommand = getSomeCommandInstance();
String result = someCommand.execute();
----

However, the command execution is blocking, so have to call the command execution either in an `executeBlocking`
block or in a worker verticle:

[source, java]
----
HystrixCommand<String> someCommand = getSomeCommandInstance();
vertx.<String>executeBlocking(
future -> future.complete(someCommand.execute()),
ar -> {
// back on the event loop
String result = ar.result();
}
);
----

If you use the async support of Hystrix, be careful that callbacks are not called in a vert.x thread and you have
to keep a reference on the context before the execution (with `link:../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--[getOrCreateContext]`,
and in the callback, switch back to the event loop using
`link:../../apidocs/io/vertx/core/Vertx.html#runOnContext-io.vertx.core.Handler-[runOnContext]`. Without this, you are loosing the Vert.x
concurrency model and have to manage the synchronization and ordering yourself:

[source, java]
----
vertx.runOnContext(v -> {
Context context = vertx.getOrCreateContext();
HystrixCommand<String> command = getSomeCommandInstance();
command.observe().subscribe(result -> {
context.runOnContext(v2 -> {
// Back on context (event loop or worker)
String r = result;
});
});
});
----
