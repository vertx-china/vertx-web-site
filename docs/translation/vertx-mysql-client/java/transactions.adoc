== 使用事务

=== 带事务的连接

您可以使用SQL `BEGIN`/`COMMIT`/`ROLLBACK` 执行事务，如果您必须这么做就必须使用 `link:../../apidocs/io/vertx/sqlclient/SqlConnection.html[SqlConnection]` 自己管理事务。

Or you can use the transaction API of `link:../../apidocs/io/vertx/sqlclient/SqlConnection.html[SqlConnection]`:
或者您使用事务API `link:../../apidocs/io/vertx/sqlclient/SqlConnection.html[SqlConnection]`：
[source,java]
----
pool.getConnection(res -> {
  if (res.succeeded()) {

    // Transaction must use a connection
    SqlConnection conn = res.result();

    // 开始事务
    conn.begin(ar0 -> {
      if (ar0.succeeded()) {
        Transaction tx = ar0.result();
        // 各种语句
        conn
          .query("INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')")
          .execute(ar1 -> {
            if (ar1.succeeded()) {
              conn
                .query("INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')")
                .execute(ar2 -> {
                  if (ar2.succeeded()) {
                    // 提交事务
                    tx.commit(ar3 -> {
                      if (ar3.succeeded()) {
                        System.out.println("Transaction succeeded");
                      } else {
                        System.out.println("Transaction failed " + ar3.cause().getMessage());
                      }
                      // 将连接返回到连接池
                      conn.close();
                    });
                  } else {
                    // 将连接返回到连接池
                    conn.close();
                  }
                });
            } else {
              // 将连接返回到连接池
              conn.close();
            }
          });
      } else {
        // 将连接返回到连接池
        conn.close();
      }
    });
  }
});
----

When the database server reports the current transaction is failed (e.g the infamous _current transaction is aborted, commands ignored until
end of transaction block_), the transaction is rollbacked and the `link:../../apidocs/io/vertx/sqlclient/Transaction.html#completion--[completion]` future
is failed with a `link:../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html[TransactionRollbackException]`:

当数据库服务器报告当前事务失败时（例如，臭名昭著的 _current transaction is aborted, commands ignored until end of transaction block_），事务被回滚，并且 `link:../../apidocs/io/vertx/sqlclient/Transaction.html#completion--[completion]` future 随着 `link:../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html[TransactionRollbackException]` 失败：

[source,java]
----
tx.completion().onFailure(err -> {
  System.out.println("Transaction failed => rollbacked");
});
----

=== 简单事务 API

当你使用连接池，您可调用 `link:../../apidocs/io/vertx/sqlclient/Pool.html#withTransaction-java.util.function.Function-io.vertx.core.Handler-[withTransaction]` 传递一个函数在事务内执行。

它从连接池中借用一个连接，开始事务，并在此事务范围内所有执行操作的客户端调用该函数。

该函数必须返回一个任意结果的future。

- 当future成功，客户端提交这个事务
- 当future失败，客户端回滚这个事务

事务完成后, 连接将返回到连接池中，并提供全部的结果。

[source,java]
----
pool.withTransaction(client -> client
  .query("INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')")
  .execute()
  .flatMap(res -> client
    .query("INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')")
    .execute()
    // 映射一个消息结果
    .map("Users inserted"))
).onComplete(ar -> {
  // 连接已自动返回到连接池中
  if (ar.succeeded()) {
    // 事务被提交
    String message = ar.result();
    System.out.println("Transaction succeeded: " + message);
  } else {
    // 事务被回滚
    System.out.println("Transaction failed " + ar.cause().getMessage());
  }
});
----