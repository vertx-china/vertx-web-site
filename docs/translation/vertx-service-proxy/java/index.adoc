= Vert.x Service Proxy
:toc: left

当你编写Vert.x程序的时候，你也许想将某处独立服务功能提供给其他程序使用。这时候可以使用服务代理了。 它可以让你在事件总线上公开你的 _服务_ , 因此，任何Vert.x程序只要知道其推送的 _地址_ 就可以消费使用它。

 _服务_ 它是遵循Java接口定义，方法定义必须遵循 _异步规范_. 更深层次下,
在事件总线上发送请求消息并调用服务响应请求。 但是为了更简单使用,
他会成为一个 _代理_ 可以直接调用 (使用服务接口的API).

[[_using_vert_x_service_proxies]]
== 使用Vert.x服务代理

使用Vert.x Service Proxy之前，你必须在你得项目当中添加 _依赖_ :

* Maven (在 `pom.xml` 文件中):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-service-proxy</artifactId>
 <version>4.0.3</version>
</dependency>
----

* Gradle (在 `build.gradle` file):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-service-proxy:4.0.0'
----

为了 *实现* 服务代理, 您还需要添加:

* Maven (在 `pom.xml` 文件中):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-codegen</artifactId>
 <version>4.0.0</version>
 <scope>provided</scope>
</dependency>
----

* Gradle版本小于 5 的情况(在 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
compileOnly 'io.vertx:vertx-codegen:4.0.0'
----

* Gradle版本大于等于 5 (在 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
annotationProcessor 'io.vertx:vertx-codegen:4.0.0:processor'
annotationProcessor 'io.vertx:vertx-service-proxy:4.0.0'
----

注意：因为服务代理类是通过代码生成的缘故，每当你你修改了 _服务接口_ 你必须重新编译编码，以重新 生成代理类。

如果你要生成不同语言的代理类，你需要添加相应的依赖。例如，生成Groovy需要添加 `vertx-lang-groovy` 依赖

[[_introduction_to_service_proxies]]
== 服务代理简介

让我看看服务代理它怎么用。 如果你在事件总线上公开 _数据库服务_ 你可以执行下面的操作

[source,java]
----
JsonObject message = new JsonObject();

message
  .put("collection", "mycollection")
  .put("document", new JsonObject().put("name", "tim"));

DeliveryOptions options = new DeliveryOptions().addHeader("action", "save");

vertx.eventBus()
  .request("database-service-address", message, options)
  .onSuccess(msg -> {
    // 完成
  }).onFailure(err -> {
  // 失败
});
----
当创建服务的时候足够的样本代码在事件总线接收信息，路由会找到合适的方法并在总线上返回

使用Vert.x服务代理时,你可以使用代码生成避免编写重复的代码，从而集中精力编写服务

在你编写的Java接口上面打上 `@ProxyGen` 注解, 例如:

[source,java]
----
@ProxyGen
public interface SomeDatabaseService {

 // 几个工程方法用于创建实例
 static SomeDatabaseService create(Vertx vertx) {
   return new SomeDatabaseServiceImpl(vertx);
 }

 static SomeDatabaseService createProxy(Vertx vertx,
   String address) {
   return new SomeDatabaseServiceVertxEBProxy(vertx, address);
 }

// 服务实际的接口订单
void save(String collection, JsonObject document,
  Handler<AsyncResult<Void>> resultHandler);
}
----

你还需要编写 `package-info.java` 文件，位置处于接口定义包中.
这个包还需要 `@ModuleGen` 注解，以方便Vert.x代码生成器生成事件总线代理代码。

.package-info.java
[source,java]
----
@io.vertx.codegen.annotations.ModuleGen(groupPackage = "io.vertx.example", name = "services")
package io.vertx.example;
----

有了这个接口，Vert.x会生成所有需要的用于在Event Bus上访问你的服务的模板代码，同时也会生成对应的 调用端代理类（client side proxy），
这样你的服务调用端就可以使用一个相当符合习惯的API（译者注：即相同的服务接口）进行服务调用，而不是去手动地向Event Bus发送消息。
不管你的服务实际在哪个Event Bus上（可能是在不同的机器上），调用端代理类都能正常工作。

也就是说，你可以通过以下方式进行服务调用：

[source,java]
----
SomeDatabaseService service = SomeDatabaseService
  .createProxy(vertx, "database-service-address");

// 保存数据到数据库，这里使用了代理
service.save(
  "mycollection",
  new JsonObject().put("name", "tim"),
  res2 -> {
    if (res2.succeeded()) {
      // 调用完毕
    }
  });
----

你也可以将多语言API生成功能（@VertxGen注解）与 @ProxyGen 注解相结合，用于生成其它Vert.x支持的JVM语言对应的服务代理 —— 这意味着你可以只用Java编写你的服务一次，就可以在其他语言中以一种习惯的API风格进行服务调用，而不必管服务是在本地还是在Event Bus的别处。
想要利用多语言代码生成功能，不要忘记添加对应支持语言的依赖。

[source,java]
----
@ProxyGen // Generate service proxies
@VertxGen // Generate the clients
public interface SomeDatabaseService {
 // ...
}
----

[[_async_interface]]
== 异步接口

想要正确地生成服务代理类，_服务接口_ 的设计必须遵循一些规则。
首先是需要遵循异步模式。
如果需要返回结果，对应的方法需要包含一个 Handler<AsyncResult<ResultType>> 类型的参数
其中 `ResultType` 可以是另一种代理类型（所以一个代理类可以作为另一个代理类的工厂）。

例如：

[source,java]
----
@ProxyGen
public interface SomeDatabaseService {

// 一些用于创建服务实例和服务代理实例的工厂方法

static SomeDatabaseService create(Vertx vertx) {
  return new SomeDatabaseServiceImpl(vertx);
}

static SomeDatabaseService createProxy(Vertx vertx, String address) {
  return new SomeDatabaseServiceVertxEBProxy(vertx, address);
}

// 异步方法，仅通知调用是否完成，不返回结果
void save(String collection, JsonObject document,
  Handler<AsyncResult<Void>> result);

// 异步方法，包含JsonObject类型的返回结果
void findOne(String collection, JsonObject query,
  Handler<AsyncResult<JsonObject>> result);

// 创建连接
void createConnection(String shoeSize,
  Handler<AsyncResult<MyDatabaseConnection>> resultHandler);

}
----

以及:

[source,java]
----
@ProxyGen
@VertxGen
public interface MyDatabaseConnection {

void insert(JsonObject someData);

void commit(Handler<AsyncResult<Void>> resultHandler);

@ProxyClose
void close();
}
----
你可以通过声明一个特殊方法，并给其加上 `@ProxyClose` 注解来注销代理。
当此方法被调用时，代理实例被清除。

更多 `服务接口` 的限制会在下面详解。

[[_security]]
== 安全

Service proxies can perform basic security using a simple interceptor.
A authentication provider must be provided, optionally `Authorization`s can be added and in this case an `AuthorizationProvider` must also be present.
Note that the authentication works based on tokens, that are extracted from the `auth-token` header.

[source,java]
----
SomeDatabaseService service = new SomeDatabaseServiceImpl();
// Register the handler
new ServiceBinder(vertx)
  .setAddress("database-service-address")
  // Secure the messages in transit
  .addInterceptor(
    new ServiceAuthInterceptor()
      // Tokens will be validated using JWT authentication
      .setAuthenticationProvider(JWTAuth.create(vertx, new JWTAuthOptions()))
      // optionally we can secure permissions too:

      // an admin
      .addAuthorization(RoleBasedAuthorization.create("admin"))
      // that can print
      .addAuthorization(PermissionBasedAuthorization.create("print"))

      // where the authorizations are loaded, let's assume from the token
      // but they could be loaded from a database or a file if needed
      .setAuthorizationProvider(
        JWTAuthorization.create("permissions")))

  .register(SomeDatabaseService.class, service);
----

[[_code_generation]]
== 代码生成
被 @ProxyGen 注解的服务接口会触发生成对应的服务辅助类：
Service annotated with `@ProxyGen` annotation trigger the generation of the service helper classes:

- 服务代理类（service proxy）：一个编译时产生的代理类，用 `EventBus` 通过消息与服务交互。
- 服务处理器类（service handler）： 一个编译时产生的 `EventBus` 处理器类，用于响应由服务代理发送的事件。

产生的服务代理和处理器的命名是在类名的后面加相关的字段，例如，如果一个服务接口名为 `MyService`，
则对应的处理器类命名为 `MyServiceProxyHandler`,对应的服务代理类命名为 MyServiceVertxEBProxy。

此外Vert.x Core提供了一个生成器用于数据转化器，以简化服务代理中数据对象的使用.
数据转化器要求数据对象提供一个以 `JsonObject` 为基础的构造器和`toJson()` 方法

_codegen_ 注释处理器在编译时生成这些类
它是Java编译器的功能 所以无需 _额外步骤_, 只需正确配置您的构建参数即可:

只需要在构建配置中加上 `io.vertx:vertx-service-proxy:processor` 依赖。

这是一个针对Maven的配置示例：

[source,xml]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-codegen</artifactId>
 <version>4.0.0</version>
 <classifier>processor</classifier>
</dependency>
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-service-proxy</artifactId>
 <version>4.0.0</version>
</dependency>
----

此功能也可以在Gradle中使用:

[source]
----
compile "io.vertx:vertx-codegen:4.0.0:processor"
compile "io.vertx:vertx-service-proxy:4.0.0"
----

IDE通常为注释处理器提供支持.
代码生成 `处理器` 分类器会把服务代理注释处理器的配置自动添加到jar中 `META-INF/services` 当中
如果你想和其与常规jar一起使用，但是需要显式声明注释处理器 , 例如在Maven中:

[source,xml]
----
<plugin>
 <artifactId>maven-compiler-plugin</artifactId>
 <configuration>
   <annotationProcessors>
     <annotationProcessor>io.vertx.codegen.CodeGenProcessor</annotationProcessor>
   </annotationProcessors>
 </configuration>
</plugin>
----

[[_exposing_your_service]]
== 公开服务

当你写好服务接口以后，执行构建操作以生成代码。
然后你需要将你的服务“注册”到Event Bus上：

[source,java]
----
SomeDatabaseService service = new SomeDatabaseServiceImpl();
// 注册处理器
new ServiceBinder(vertx)
  .setAddress("database-service-address")
  .register(SomeDatabaseService.class, service);
----

这个过程既可以在 Verticle 中完成，也可以在你的代码的任何其它位置完成。

一旦注册了，这个服务就可用了。如果你的应用运行在集群上，则集群中节点都可访问。

如果想注销这个服务, 使用 `link:../../apidocs/io/vertx/serviceproxy/ServiceBinder.html#unregister-io.vertx.core.eventbus.MessageConsumer-[unregister]`
方法注销:

[source,java]
----
ServiceBinder binder = new ServiceBinder(vertx);

// 创建服务实例
SomeDatabaseService service = new SomeDatabaseServiceImpl();
// 注册处理器
MessageConsumer<JsonObject> consumer = binder
  .setAddress("database-service-address")
  .register(SomeDatabaseService.class, service);

// ....

// 注销服务.
binder.unregister(consumer);
----

[[_proxy_creation]]
== 代理创建

现在服务已经公开, 现在可以消费使用它.
为此, 你必须创建一个代理.
创建代理使用 `link:../../apidocs/io/vertx/serviceproxy/ServiceProxyBuilder.html[ServiceProxyBuilder]` 类:

[source,java]
----
ServiceProxyBuilder builder = new ServiceProxyBuilder(vertx)
  .setAddress("database-service-address");

SomeDatabaseService service = builder.build(SomeDatabaseService.class);
// 设置其他属性:
SomeDatabaseService service2 = builder.setOptions(options)
  .build(SomeDatabaseService.class);
----

第二种构造通过 `link:../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html[DeliveryOptions]` 构造实例，您可以在其中配置属性（例如超时）

或者,你也可以使用代理类.
这个代理名称为 _服务接口_ 类目后追加 `VertxEBProxy`.
例如, 如果你的 _服务接口_ 名为 `SomeDatabaseService`, 那么代理类名为 `SomeDatabaseServiceVertxEBProxy`。

一般来说, _服务接口_ 包含 `createProxy` 静态方法用于创建代理。
但这不是必须的:

[source,java]
----
@ProxyGen
public interface SomeDatabaseService {

// 静态方法创建代理
static SomeDatabaseService createProxy(Vertx vertx, String address) {
  return new SomeDatabaseServiceVertxEBProxy(vertx, address);
}

// ...
}
----

[[_error_handling]]
== 错误处理
服务方法可能会通过向方法的处理器（Handler）传递一个失败状态的 Future （包含一个 `link:../../apidocs/io/vertx/serviceproxy/ServiceException.html[ServiceException]`
实例。
一个 `ServiceException` 包含 `int` 类型的错误码、消息,以及一个可选的
`JsonObject` 对象用于传递额外信息.
为了方便,
`link:../../apidocs/io/vertx/serviceproxy/ServiceException.html#fail-int-java.lang.String-[ServiceException.fail]` 工厂方法来创建一个已经是失败状态并且包装着
`ServiceException` 实例的失败 `Future`.
例如:

[source,java]
----
public class SomeDatabaseServiceImpl implements SomeDatabaseService {
private static final BAD_SHOE_SIZE = 42;
private static final CONNECTION_FAILED = 43;

 // 创建连接
 void createConnection(String shoeSize, Handler<AsyncResult<MyDatabaseConnection>> resultHandler) {
   if (!shoeSize.equals("9")) {
     resultHandler.handle(ServiceException.fail(BAD_SHOE_SIZE, "The shoe size must be 9!",
       new JsonObject().put("shoeSize", shoeSize));
    } else {
       doDbConnection(result -> {
         if (result.succeeded()) {
           resultHandler.handle(Future.succeededFuture(result.result()));
         } else {
           resultHandler.handle(ServiceException.fail(CONNECTION_FAILED, result.cause().getMessage()));
         }
       });
    }
 }
}
----

服务调用端（client side）可以检查它接收到的失败状态的AsyncResult包含的Throwable对象是否为ServiceException实例。如果是的话，继续检查内部的特定的错误状态码。
调用端可以通过这些信息来将业务逻辑错误与系统错误（如服务没有被注册到Event Bus上）区分开，以便确定到底发生了哪一种业务逻辑错误。下面是一个例子：

[source,java]
----
public void foo(String shoeSize, Handler<AsyncResult<JsonObject>> handler) {
 SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);
 service.createConnection("8", result -> {
   if (result.succeeded()) {
     // 正常调用.
   } else {
     if (result.cause() instanceof ServiceException) {
       ServiceException exc = (ServiceException) result.cause();
       if (exc.failureCode() == SomeDatabaseServiceImpl.BAD_SHOE_SIZE) {
         handler.handle(Future.failedFuture(
           new InvalidInputError("You provided a bad shoe size: " +
             exc.getDebugInfo().getString("shoeSize"))
         ));
       } else if (exc.failureCode() == SomeDatabaseServiceImpl.CONNECTION) {
         handler.handle(Future.failedFuture(
           new ConnectionError("Failed to connect to the DB")));
       }
     } else {
       //可能是一个系统错误(system error)，如服务代理没有对应的已注册的服务
       handler.handle(Future.failedFuture(
         new SystemError("An unexpected error occurred: + " result.cause().getMessage())
       ));
     }
   }
 }
}
----

如果需要的话, 服务实现的时候也可以返回 `ServiceException` 子类, 只要向Event Bus注册了对应的默认 `MessageCodec` 就可以了。例如, 比如给定下面的 `ServiceException` 子类:

[source,java]
----
class ShoeSizeException extends ServiceException {
 public static final BAD_SHOE_SIZE_ERROR = 42;

 private final String shoeSize;

 public ShoeSizeException(String shoeSize) {
   super(BAD_SHOE_SIZE_ERROR, "In invalid shoe size was received: " + shoeSize);
   this.shoeSize = shoeSize;
 }

 public String getShoeSize() {
   return extra;
 }

 public static <T> AsyncResult<T> fail(int failureCode, String message, String shoeSize) {
   return Future.failedFuture(new MyServiceException(failureCode, message, shoeSize));
 }
}
----

只要向Event Bus注册了对应的 `MessageCodec` , 服务就可以直接向调用者返回自定义的异常类型:

[source,java]
----
public class SomeDatabaseServiceImpl implements SomeDatabaseService {
 public SomeDataBaseServiceImpl(Vertx vertx) {
   // Register on the service side. If using a local event bus, this is all
   // that's required, since the proxy side will share the same Vertx instance.
 SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);
   vertx.eventBus().registerDefaultCodec(ShoeSizeException.class,
     new ShoeSizeExceptionMessageCodec());
 }

 // Create a connection
 void createConnection(String shoeSize, Handler<AsyncResult<MyDatabaseConnection>> resultHandler) {
   if (!shoeSize.equals("9")) {
     resultHandler.handle(ShoeSizeException.fail(shoeSize));
   } else {
     // Create the connection here
     resultHandler.Handle(Future.succeededFuture(myDbConnection));
   }
 }
}
----

最后调用端可以检查自定义的异常类型了：

[source,java]
----
public void foo(String shoeSize, Handler<AsyncResult<JsonObject>> handler) {
 // 如果运行在集群模式当中，代码在不同的节点运行,
 // ShoeSizeExceptionMessageCodec 必须注册到
 // 该节点的Vertx当中
 SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);
 service.createConnection("8", result -> {
   if (result.succeeded()) {
     // 成功调用.
   } else {
     if (result.cause() instanceof ShoeSizeException) {
       ShoeSizeException exc = (ShoeSizeException) result.cause();
       handler.handle(Future.failedFuture(
         new InvalidInputError("You provided a bad shoe size: " + exc.getShoeSize())));
     } else {
       // Must be a system error (e.g. No service registered for the proxy)
       handler.handle(Future.failedFuture(
         new SystemError("An unexpected error occurred: + " result.cause().getMessage())
       ));
     }
   }
 }
}
----

注意在`Vertx` 集群模式下，你需要向集群中每个节点的Event Bus注册对应的自定义异常类型
的 `MessageCodec` 实例

[[_restrictions_for_service_interface]]
== 接口类型限制

There are restrictions on the types and return values that can be used in a service method so that these are easy to marshall over event bus messages and so they can be used asynchronously.
They are:

=== 返回类型

必须是以下两种:

* `void`
* `@Fluent` 返回服务实例本身(即:`this`):

[source,java]
----
@Fluent
SomeDatabaseService doSomething();
----

这是因为方法不能被阻塞，远程服务是不可能立即返回结果并不阻塞

=== 参数类型

类型简写说明：

- `JSON` = `JsonObject 或 JsonArray`
- `PRIMITIVE` = 任何原始类型或被自动拆装箱的原始类型

参数可以是以下任意一种:

* `JSON`
* `PRIMITIVE`
* `List<JSON>`
* `List<PRIMITIVE>`
* `Set<JSON>`
* `Set<PRIMITIVE>`
* `Map<String, JSON>`
* `Map<String, PRIMITIVE>`
* 任何 _枚举_ 类型
* 任何被打上 `@DataObject` 注解的实体类

如果需要返回异步结果，可以提供一个 `Handler<AsyncResult<R>>` 。

`R` 的类型可以是:

* `JSON`
* `PRIMITIVE`
* `List<JSON>`
* `List<PRIMITIVE>`
* `Set<JSON>`
* `Set<PRIMITIVE>`
* 任何 _枚举_ 类型
* 任何打上 `@DataObject` 注解的类（需符合上文的代码篇章要求）
* 另一个代理类

=== 重载方法

服务接口不支持任何的重载服务方法. (即方法名相同，参数列表不同).

[_convention_for_invoking_services_over_the_event_bus_without_proxies]
== 通过事件总线调用服务的规则 (不使用服务代理)

服务代理假定Event Bus中的消息遵循一定的格式，因此能被用于服务的调用

当然，如果不愿意的话，你也可以 *不用* 服务代理类来访问远程服务。
被广泛接受的与服务交互的方式就是直接在Event Bus发送消息。

为了使服务访问的方式一致，所有的服务都必须遵循以下的消息格式。

格式非常简单：

* 需要有一个名为 `action` 的 消息头(header)，作为要执行操作的名称。
* 消息体（message body）应该是一个 `JsonObject` 对象，里面需要包含操作需要的所有参数。

举个例子，假如我们要去执行一个名为 `save` 的操作，此操作接受一个字符串类型的 collection 和 JsonObject 类型 document:

----
Headers:
   "action": "save"
Body:
   {
       "collection", "mycollection",
       "document", {
           "name": "tim"
       }
   }
----

无论有没有用到服务代理来创建服务，都应该用上面这种方式编写服务，因为这样允许服务交互时保持一致性.

在上面的例子中，"action"对应的值应该与服务接口的某个方法名称相对应，而消息体中每个 `[key, value]` 都要与服务方法中的某个 `[arg_name, arg_value]` 相对应

对于返回值，服务需使用 `message.reply(...)` 方法去向调用端发送回一个返回值 -  这个值可以是Event Bus支持的任何类型。
如果需要表示调用失败，可以调用 `message.fail(...)` 方法。

如果你使用Vert.x 服务代理组件的话，生成的代码会自动帮你处理这些问题。