= JWT 认证

该组件包含了一个现成的JWT实现，要使用这个项目，将下面的依赖添加到构建描述符里的
_dependencies_ 部分

* Maven (在你的 `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-auth-jwt</artifactId>
 <version>4.0.0</version>
</dependency>
----

* Gradle (在你的 `build.gradle` 文件):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-auth-jwt:4.0.0'
----

JSON Web 令牌是一种简单的方法来发送明文信息（通常是URL），其内容可以被验证为是可信的。
像下面的这些场景JWT是非常适用的：

* 在单点登录方案中，需要一个单独的身份验证服务器，然后该服务器可以以受信任的方式发送用户信息.
* 无状态的API 服务, 非常适合单页应用.
* 等等...

在决定使用JWT之前, 需要重点注意的是JWT并不加密payload, 沓子对它签名. 你
你不应该使用JWT发送任何私密信息, 相反你应该发送是不是私密的
但要被验证的信息。举个例子, 使用JWT发送一个签名过的用户id来表明这个用户已经登录了的做法非常对的!
相反发送一个用户的密码的做法是非常非常错误的.

JWT主要的优点有:

* 它可以让你验证令牌的真实性。
* 它有一个JSON结构，可以包含任何你想要的变量和大量的数据。
* 它是无状态的.

你可以使用 `link:../../apidocs/io/vertx/ext/auth/jwt/JWTAuth.html[JWTAuth]` 来创建一个提供者的实例。
并指定一个JSON对象的配置。

这是创建一个JWT auth提供者的示例代码：

[source,java]
----
JWTAuthOptions config = new JWTAuthOptions()
  .setKeyStore(new KeyStoreOptions()
    .setPath("keystore.jceks")
    .setPassword("secret"));

AuthenticationProvider provider = JWTAuth.create(vertx, config);
----

JWT用法的典型流程是，在您的应用程序有一个端点颁发令牌, 这个端点应在
SSL模式下运行, 端点这通过用户名和密码验证完请求用户之后，表示你将这样做生成
令牌:

[source,java]
----
JWTAuthOptions config = new JWTAuthOptions()
  .setKeyStore(new KeyStoreOptions()
    .setPath("keystore.jceks")
    .setPassword("secret"));

JWTAuth provider = JWTAuth.create(vertx, config);

// 验用户的用户名和密码之后，
// 通过端点生成签名令牌
if ("paulo".equals(username) && "super_secret".equals(password)) {
  String token = provider.generateToken(
    new JsonObject().put("sub", "paulo"), new JWTOptions());

  // 现在，对于任何对受保护资源的请求，你应该
  // 检查他们的HTTP头中Authorization字符串:
  // Authorization: Bearer <token>
}
----

[_Loading_keys_]
=== 加载秘钥

秘钥可以通过三种不同的方式载入:

* 使用 secrets (对称秘钥)
* 使用 OpenSSL 生成的 `pem` 格式文件 (公钥)
* 使用 Java Keystore 文件 (对称加密公钥)

==== 使用对称秘钥

JWT的默认签名方法称为 `HS256`。 `HS` 默认表示为 `HMAC 加密 使用 SHA256`.

这是最简单的加载秘钥方式了. 你只需要将secret与第三方共享, 举个例子
假设 secret 是: `keyboard cat` 那么你可以将Auth配置为:

[source,java]
----
JWTAuth provider = JWTAuth.create(vertx, new JWTAuthOptions()
  .addPubSecKey(new PubSecKeyOptions()
    .setAlgorithm("HS256")
    .setBuffer("keyboard cat")));

String token = provider.generateToken(new JsonObject());
----

在这种情况下secret将被设置为公钥, 因为这是双方都知道的令牌，你可以配置
你的PubSec配置为对称。

==== 使用 RSA 秘钥

这部分不是 OpenSSL 文档，建议阅读OpenSSL文档了解命令的使用。 我们将
介绍如何生成最通用的密钥以及如何和JWT auth一起使用。

想象一下，你想使用非常常见的 `RS256` 加密算法来保护您的资源。 与你想象
相反, 256 不是秘钥长度而是哈希算法的签名长度. 任何RSA秘钥都和JWT
加密算法一期使用. 这里是信息表:

[width="80%",cols="e,>s",options="header"]
|=========================================================
|"alg" 参数值 |数字签名算法

|RS256 |RSASSA-PKCS1-v1_5 using SHA-256

|RS384 |RSASSA-PKCS1-v1_5 using SHA-384

|RS512 |RSASSA-PKCS1-v1_5 using SHA-512

|=========================================================

如果您想生成一个2048位RSA密钥对, 那么你应该(请记住 **不要** 添加密码，
JWT auth将无法载入秘钥文件):

----
openssl genrsa -out private.pem 2048
----

如果你看到类似的文件内容，那么恭喜你秘钥文件正确的生成了；

----
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAxPSbCQY5mBKFDIn1kggvWb4ChjrctqD4nFnJOJk4mpuZ/u3h
...
e4k0yN3F1J1DVlqYWJxaIMzxavQsi9Hz4p2JgyaZMDGB6kGixkMo
-----END RSA PRIVATE KEY-----
----

标准的JDK是无法读取的该文件的，所以我们 **必须** 将它转换成 PKCS8 标准的格式的:

----
openssl pkcs8 -topk8 -inform PEM -in private.pem -out private_key.pem -nocrypt
----

现在是一个包含类似内容，全新的 `private_key.pem` 秘钥文件了；

----
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDE9JsJBjmYEoUM
...
0fPinYmDJpkwMYHqQaLGQyg=
-----END PRIVATE KEY-----
----

如果你只验证令牌 (你只需要 private_key.pem 文件) 但是某些时候你需要
签发令牌, 所以你需要一个公钥。在这种情况下你需要从私钥文件中提取公钥文件:

----
openssl rsa -in private.pem -outform PEM -pubout -out public.pem
----

你会看到类似内容的文件:

----
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxPSbCQY5mBKFDIn1kggv
...
qwIDAQAB
-----END PUBLIC KEY-----
----

现在可以校验令牌有效性了:

[source,java]
----
JWTAuth provider = JWTAuth.create(vertx, new JWTAuthOptions()
  .addPubSecKey(new PubSecKeyOptions()
    .setAlgorithm("RS256")
    .setBuffer(
      "-----BEGIN PUBLIC KEY-----\n" +
        "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxPSbCQY5mBKFDIn1kggv\n" +
        "Wb4ChjrctqD4nFnJOJk4mpuZ/u3h2ZgeKJJkJv8+5oFO6vsEwF7/TqKXp0XDp6IH\n" +
        "byaOSWdkl535rCYR5AxDSjwnuSXsSp54pvB+fEEFDPFF81GHixepIbqXCB+BnCTg\n" +
        "N65BqwNn/1Vgqv6+H3nweNlbTv8e/scEgbg6ZYcsnBBB9kYLp69FSwNWpvPmd60e\n" +
        "3DWyIo3WCUmKlQgjHL4PHLKYwwKgOHG/aNl4hN4/wqTixCAHe6KdLnehLn71x+Z0\n" +
        "SyXbWooftefpJP1wMbwlCpH3ikBzVIfHKLWT9QIOVoRgchPU3WAsZv/ePgl5i8Co\n" +
        "qwIDAQAB\n" +
        "-----END PUBLIC KEY-----"))
  .addPubSecKey(new PubSecKeyOptions()
    .setAlgorithm("RS256")
    .setBuffer(
      "-----BEGIN PRIVATE KEY-----\n" +
        "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDE9JsJBjmYEoUM\n" +
        "ifWSCC9ZvgKGOty2oPicWck4mTiam5n+7eHZmB4okmQm/z7mgU7q+wTAXv9Oopen\n" +
        "RcOnogdvJo5JZ2SXnfmsJhHkDENKPCe5JexKnnim8H58QQUM8UXzUYeLF6khupcI\n" +
        "H4GcJOA3rkGrA2f/VWCq/r4fefB42VtO/x7+xwSBuDplhyycEEH2Rgunr0VLA1am\n" +
        "8+Z3rR7cNbIijdYJSYqVCCMcvg8cspjDAqA4cb9o2XiE3j/CpOLEIAd7op0ud6Eu\n" +
        "fvXH5nRLJdtaih+15+kk/XAxvCUKkfeKQHNUh8cotZP1Ag5WhGByE9TdYCxm/94+\n" +
        "CXmLwKirAgMBAAECggEAeQ+M+BgOcK35gAKQoklLqZLEhHNL1SnOhnQd3h84DrhU\n" +
        "CMF5UEFTUEbjLqE3rYGP25mdiw0ZSuFf7B5SrAhJH4YIcZAO4a7ll23zE0SCW+/r\n" +
        "zr9DpX4Q1TP/2yowC4uGHpBfixxpBmVljkWnai20cCU5Ef/O/cAh4hkhDcHrEKwb\n" +
        "m9nymKQt06YnvpCMKoHDdqzfB3eByoAKuGxo/sbi5LDpWalCabcg7w+WKIEU1PHb\n" +
        "Qi+RiDf3TzbQ6TYhAEH2rKM9JHbp02TO/r3QOoqHMITW6FKYvfiVFN+voS5zzAO3\n" +
        "c5X4I+ICNzm+mnt8wElV1B6nO2hFg2PE9uVnlgB2GQKBgQD8xkjNhERaT7f78gBl\n" +
        "ch15DRDH0m1rz84PKRznoPrSEY/HlWddlGkn0sTnbVYKXVTvNytKSmznRZ7fSTJB\n" +
        "2IhQV7+I0jeb7pyLllF5PdSQqKTk6oCeL8h8eDPN7awZ731zff1AGgJ3DJXlRTh/\n" +
        "O6zj9nI8llvGzP30274I2/+cdwKBgQDHd/twbiHZZTDexYewP0ufQDtZP1Nk54fj\n" +
        "EpkEuoTdEPymRoq7xo+Lqj5ewhAtVKQuz6aH4BeEtSCHhxy8OFLDBdoGCEd/WBpD\n" +
        "f+82sfmGk+FxLyYkLxHCxsZdOb93zkUXPCoCrvNRaUFO1qq5Dk8eftGCdC3iETHE\n" +
        "6h5avxHGbQKBgQCLHQVMNhL4MQ9slU8qhZc627n0fxbBUuhw54uE3s+rdQbQLKVq\n" +
        "lxcYV6MOStojciIgVRh6FmPBFEvPTxVdr7G1pdU/k5IPO07kc6H7O9AUnPvDEFwg\n" +
        "suN/vRelqbwhufAs85XBBY99vWtxdpsVSt5nx2YvegCgdIj/jUAU2B7hGQKBgEgV\n" +
        "sCRdaJYr35FiSTsEZMvUZp5GKFka4xzIp8vxq/pIHUXp0FEz3MRYbdnIwBfhssPH\n" +
        "/yKzdUxcOLlBtry+jgo0nyn26/+1Uyh5n3VgtBBSePJyW5JQAFcnhqBCMlOVk5pl\n" +
        "/7igiQYux486PNBLv4QByK0gV0SPejDzeqzIyB+xAoGAe5if7DAAKhH0r2M8vTkm\n" +
        "JvbCFjwuvhjuI+A8AuS8zw634BHne2a1Fkvc8c3d9VDbqsHCtv2tVkxkKXPjVvtB\n" +
        "DtzuwUbp6ebF+jOfPK0LDuJoTdTdiNjIcXJ7iTTI3cXUnUNWWphYnFogzPFq9CyL\n" +
        "0fPinYmDJpkwMYHqQaLGQyg=\n" +
        "-----END PRIVATE KEY-----")
  ));

String token = provider.generateToken(
  new JsonObject().put("some", "token-data"),
  new JWTOptions().setAlgorithm("RS256"));
----

==== 使用 EC 秘钥

我们还支持椭圆曲线加密算法，但是在默认JDK上面使用有一定限制

用法和RSA加密算法极其相似, 首先你需要创建一个公钥：

----
openssl ecparam -name secp256r1 -genkey -out private.pem
----

然后你会看到类似内容的文件了:

----
-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIMZGaqZDTHL+IzFYEWLIYITXpGzOJuiQxR2VNGheq7ShoAoGCCqGSM49
AwEHoUQDQgAEG1O9LCrP6hg3Y9q68+LF0q48UcOkwVKE1ax0b56wjVusf3qnuFO2
/+XHKKhtzEavvFMeXRQ+ZVEqM0yGNb04qw==
-----END EC PRIVATE KEY-----
----

但是JDK支持此PKCS8格式的，我们必须将它装换；

----
openssl pkcs8 -topk8 -nocrypt -in private.pem -out private_key.pem
----

然后会看到类似的内容的文件:

----
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgxkZqpkNMcv4jMVgR
YshghNekbM4m6JDFHZU0aF6rtKGhRANCAAQbU70sKs/qGDdj2rrz4sXSrjxRw6TB
UoTVrHRvnrCNW6x/eqe4U7b/5ccoqG3MRq+8Ux5dFD5lUSozTIY1vTir
-----END PRIVATE KEY-----
----

使用私钥你可以生成令牌了:

[source,java]
-----
JWTAuth provider = JWTAuth.create(vertx, new JWTAuthOptions()
  .addPubSecKey(new PubSecKeyOptions()
    .setAlgorithm("ES256")
    .setBuffer(
      "-----BEGIN PRIVATE KEY-----\n" +
        "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgeRyEfU1NSHPTCuC9\n" +
        "rwLZMukaWCH2Fk6q5w+XBYrKtLihRANCAAStpUnwKmSvBM9EI+W5QN3ALpvz6bh0\n" +
        "SPCXyz5KfQZQuSj4f3l+xNERDUDaygIUdLjBXf/bc15ur2iZjcq4r0Mr\n" +
        "-----END PRIVATE KEY-----\n")
  ));

String token = provider.generateToken(
  new JsonObject(),
  new JWTOptions().setAlgorithm("ES256"));
-----

为了验证令牌你还需要一个公钥：

----
openssl ec -in private.pem -pubout -out public.pem
----

现在你可以用它进行全部操作了:

[source,java]
----
JWTAuth provider = JWTAuth.create(vertx, new JWTAuthOptions()
  .addPubSecKey(new PubSecKeyOptions()
    .setAlgorithm("ES256")
    .setBuffer(
      "-----BEGIN PUBLIC KEY-----\n" +
        "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEraVJ8CpkrwTPRCPluUDdwC6b8+m4\n" +
        "dEjwl8s+Sn0GULko+H95fsTREQ1A2soCFHS4wV3/23Nebq9omY3KuK9DKw==\n" +
        "-----END PUBLIC KEY-----"))
  .addPubSecKey(new PubSecKeyOptions()
    .setAlgorithm("RS256")
    .setBuffer(
      "-----BEGIN PRIVATE KEY-----\n" +
        "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgeRyEfU1NSHPTCuC9\n" +
        "rwLZMukaWCH2Fk6q5w+XBYrKtLihRANCAAStpUnwKmSvBM9EI+W5QN3ALpvz6bh0\n" +
        "SPCXyz5KfQZQuSj4f3l+xNERDUDaygIUdLjBXf/bc15ur2iZjcq4r0Mr")
  ));

String token = provider.generateToken(
  new JsonObject(),
  new JWTOptions().setAlgorithm("ES256"));
----

==== JWT keystore 文件

如果你喜欢用Java Keystores格式的秘钥文件, 那么下文可以做到这一点.

身份认证器需要classpath上或文件路径上加载一个秘钥库，以供
`https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html[javax.crypto.Mac]`
或 `https://docs.oracle.com/javase/8/docs/api/java/security/Signature.html[java.security.Signature]`
生成或认证令牌。

The implementation will, by default, look for the following aliases, however not all are required to be present. As
a good practice `HS256` should be present:
----
`HS256`:: HMAC using SHA-256 hash algorithm
`HS384`:: HMAC using SHA-384 hash algorithm
`HS512`:: HMAC using SHA-512 hash algorithm
`RS256`:: RSASSA using SHA-256 hash algorithm
`RS384`:: RSASSA using SHA-384 hash algorithm
`RS512`:: RSASSA using SHA-512 hash algorithm
`ES256`:: ECDSA using P-256 curve and SHA-256 hash algorithm
`ES384`:: ECDSA using P-384 curve and SHA-384 hash algorithm
`ES512`:: ECDSA using P-521 curve and SHA-512 hash algorithm
----

When no keystore is provided the implementation falls back in unsecure mode and signatures will not be verified, this
is useful for the cases where the payload if signed and or encrypted by external means.

Key pairs stored on a keystore always include a certificate. The validity of the certificate is tested on load and keys
will not be loaded if either expired or not yet valid to be use.

All keys algorithms will be checked if can be matched to the given alias. For example an `RS256` key will not be loaded
if issued with a `EC` algorithm, or if issued with `RSA` but signature `SHA1WithRSA` instead of `SHA256WithRSA`.

===== 生成新的Keystore格式秘钥

生成秘钥文件需要唯一的工具是 `keytool`, 您现在可以运行命令行并指定特定的
算法:

----
keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA256 -keysize 2048 -alias HS256 -keypass secret
keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA384 -keysize 2048 -alias HS384 -keypass secret
keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA512 -keysize 2048 -alias HS512 -keypass secret
keytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS256 -keypass secret -sigalg SHA256withRSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS384 -keypass secret -sigalg SHA384withRSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS512 -keypass secret -sigalg SHA512withRSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 256 -alias ES256 -keypass secret -sigalg SHA256withECDSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 384 -alias ES384 -keypass secret -sigalg SHA384withECDSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 521 -alias ES512 -keypass secret -sigalg SHA512withECDSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
----

有关更多keystores的信息以及如何使用 `PKCS12` 格式秘钥 (默认：Java版本 >=9)
请参阅通用模块的文档。

=== 读取令牌

If you need to consume JWT tokens issues by third parties you probably won't have the private key with you, in that
case all you need to have is a public key im PEM format.

[source,java]
----
JWTAuthOptions config = new JWTAuthOptions()
  .addPubSecKey(new PubSecKeyOptions()
    .setAlgorithm("RS256")
    .setBuffer("BASE64-ENCODED-PUBLIC_KEY"));

AuthenticationProvider provider = JWTAuth.create(vertx, config);
----

== AuthN/AuthZ with JWT

A common scenario when developing for example micro services is that you want you application to consume APIs. These
api's are not meant to be consumed by humans so we should remove all the interactive part of authenticating the
consumer out of the picture.

In this scenario one can use HTTP as the protocol to consume this API and the HTTP protocol already defines that there
is a header `Authorization` that should be used for passing authorization information. In most cases you will see that
tokens are sent as bearer tokens, i.e.: `Authorization: Bearer some+base64+string`.

=== Authenticating (AuthN)

For this provider a user is authenticated if the token passes the signature checks and that the token is not expired.
For this reason it is imperative that private keys are kept private and not copy pasted across project since it would
be a security hole.

[source,java]
----
jwtAuth.authenticate(new JsonObject().put("jwt", "BASE64-ENCODED-STRING"))
  .onSuccess(user -> System.out.println("User: " + user.principal()))
  .onFailure(err -> {
    // Failed!
  });
----

In a nutshell the provider is checking for several things:

* token signature is valid against internal private key
* fields: `exp`, `iat`, `nbf`, `audience`, `issuer` are valid according to the config

If all these are valid then the token is considered good and a user object is returned.

While the fields `exp`, `iat` and `nbf` are simple timestamp checks only `exp` can be configured to be ignored:

[source,java]
----
jwtAuth.authenticate(
  new JsonObject()
    .put("jwt", "BASE64-ENCODED-STRING")
    .put("options", new JsonObject()
      .put("ignoreExpiration", true)))
  .onSuccess(user -> System.out.println("User: " + user.principal()))
  .onFailure(err -> {
    // Failed!
  });
----

In order to verify the `aud` field one needs to pass the options like before:

[source,java]
----
jwtAuth.authenticate(
  new JsonObject()
    .put("jwt", "BASE64-ENCODED-STRING")
    .put("options", new JsonObject()
      .put("audience", new JsonArray().add("paulo@server.com"))))
  .onSuccess(user -> System.out.println("User: " + user.principal()))
  .onFailure(err -> {
    // Failed!
  });
----

And the same for the issuer:

[source,java]
----
jwtAuth.authenticate(
  new JsonObject()
    .put("jwt", "BASE64-ENCODED-STRING")
    .put("options", new JsonObject()
      .put("issuer", "mycorp.com")))
  .onSuccess(user -> System.out.println("User: " + user.principal()))
  .onFailure(err -> {
    // Failed!
  });
----

=== Authorizing (AuthZ)

Once a token is parsed and is valid we can use it to perform authorization tasks. The most simple is to verify if a
user has a specific authority. Authorization will follow the common `link:../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html[AuthorizationProvider]`
API. Choose the provider that generated your token and evaluate.

Currently there are 2 factories:

* `link:../../apidocs/io/vertx/ext/auth/jwt/authorization/JWTAuthorization.html[JWTAuthorization]` inspects tokens based on the "permissions" claim key.
* `link:../../apidocs/io/vertx/ext/auth/jwt/authorization/MicroProfileAuthorization.html[MicroProfileAuthorization]` inspects tokens based on the <a href="https://www.eclipse.org/community/eclipse_newsletter/2017/september/article2.php">MP JWT spec</a>.

The typical usage is to extract the permissions form the user object using the provider and perform the attestation:

[source,java]
----
AuthorizationProvider authz = MicroProfileAuthorization.create();

authz.getAuthorizations(user)
  .onSuccess(v -> {
    // and now we can perform checks as needed
    if (PermissionBasedAuthorization.create("create-report").match(user)) {
      // Yes the user can create reports
    }
  });
----

By default the provider will lookup under the key `permissions` but like the other providers one can extend the
concept to authorities to roles by using the `:` as a splitter, so `role:authority` can be used to lookup the token.

Since JWT are quite free form and there is no standard on where to lookup for the claims the location can be
configured to use something else than `permissions`, for example one can even lookup under a path like this:

[source,java]
----
JsonObject config = new JsonObject()
  .put("public-key", "BASE64-ENCODED-PUBLIC_KEY")
  // since we're consuming keycloak JWTs we need
  // to locate the permission claims in the token
  .put("permissionsClaimKey", "realm_access/roles");

AuthenticationProvider provider =
  JWTAuth.create(vertx, new JWTAuthOptions(config));
----

So in this example we configure the JWT to work with Keycloak token format. In this case the claims will be checked
under the path `realm_access/roles` rather than `permissions`.

=== 校验令牌

When the method `authenticate` is invoked, the token is validated against the `JWTOptions` provided during the
initialization. The validation performs the following steps:

1. if `ignoreExpiration` (default is false) is false then the token is checked for expiration, this will check the
  fields: `exp`, `iat` and `nbf`. Since sometimes clocks are not reliable, it is possible to configure some `leeway`
  to be applied to the dates so we allow some grace period if the dates are outside the required limits.
2. if `audience` is provided, then the token `aud` is checked against the configured one and all configured audiences
  must be in the token.
3. if `issuer` is configured, then the tokens `iss` is checked against the configured one.

Once these validations complete a JWTUser object is then returned, the object is configured with a reference to the
permission claims key provided in the configuration. This value is used later when doing authorization. The value
corresponds to the json path where authorities should be checked.

=== 自定义 Token 生成

In the same way tokens are validated, the generation is initially configured during the initialization.

When generating a token an optional extra parameter can be supplied to control the token generation, this is a
`JWTOptions` object. The token signature algorithm (default HS256) can be configured using the property `algorithm`.
In this case a lookup for a key that corresponds to the algorithm is performed and used to sign.

Token headers can be added by specifying any extra headers to be merged with the default ones using the options `headers`
property.

Sometimes it might be useful to issue tokens without a timestamp (test, development time for example) in this case the
property `noTimestamp` should be set to true (default false). This means that there is no `iat` field in the token.

Token expiration is controlled by the property `expiresInSeconds`, by default there is no expiration. Other control
fields `audience`, `issuer` and `subject` are then picked from the config is available and added to the token metadata.

Finally the token is signed and encoded in the correct format.