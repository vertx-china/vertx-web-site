= Vert.x Core 文档手册
:toc: left

Vert.x 的核心 Java API 被我们称为 *Vert.x Core*

https://github.com/eclipse/vert.x[Github仓库].

Vert.x Core 提供了下列功能：

* 编写 TCP 客户端和服务端
* 编写支持 WebSocket 的 HTTP 客户端和服务端
* 事件总线
* 共享数据 —— 本地的Map和分布式集群Map
* 周期性、延迟性动作
* 部署和撤销 Verticle 实例
* 数据报套接字
* DNS客户端
* 文件系统访问
* 高可用性
* 本地传输
* 集群

Vert.x Core中的功能相当底层，不包含诸如数据库访问、授权或高层Web应用的功能。
您可以在 *Vert.x ext* （扩展包）（译者注：Vert.x的扩展包是Vert.x的子项目集合，类似 link:../../vertx-web/java/[Web]、 link:../../vertx-web-client/java/[Web Client]、 link:../../#databases[Databases]等）中找到这些功能。

*Vert.x Core* 小巧而轻便，您可以只使用您需要的部分，
它可整体嵌入现存应用中。
Vert.x没有强制要求使用特定的方式构造应用。

Vert.x也支持在其他语言中使用Vert.x Core，
而且在使用诸如 JavaScript 或 Ruby 等语言编写Vert.x代码时，无需直接调用 Java的API；毕竟不同的语言有不同的代码风格，
若强行让 Ruby 开发人员遵循 Java 的代码风格会很怪异，
所以我们根据 Java API 自动生成了适应不同语言代码风格的 API。

From now on we'll just use the word *core* to refer to Vert.x core.

include::override/dependencies.adoc[]

接下来讨论 Vert.x Core 的概念和特性。

include::override/in-the-beginning.adoc[]

== 是流式的吗？

您也许注意到前边的例子里使用了一个 *流式（Fluent）* 的API。

一个流式的API表示将多个方法的调用链在一起。例如：

[source,java]
----
request.response().putHeader("Content-Type", "text/plain").end("some text");
----

这是贯穿 Vert.x API 中的一个通用模式，所以请适应这种代码风格。

流式调用可以让代码更为简洁。
当然，Vert.x并 *不强制* 您用这种方式书写代码，如果您更倾向于用以下非流式编码，
您可以忽略它：

[source,java]
----
HttpServerResponse response = request.response();
response.putHeader("Content-Type", "text/plain");
response.write("some text");
response.end();
----

== Don't call us, we'll call you.

Vert.x 的 API 大部分都是 _事件驱动_ 的。这意味着当您感兴趣的事情发生时，
会以事件的形式发送给您。

以下是一些事件的例子：

* 触发一个计时器
* Socket 收到了一些数据
* 从磁盘中读取了一些数据
* 发生了一个异常
* HTTP 服务器收到了一个请求

Vert.x API调用您提供的 _处理器_ 来处理事件。
例如每隔一秒发送一个事件的计时器：

[source,java]
----
vertx.setPeriodic(1000, id -> {
  // 这个处理器将会每隔一秒被调用一次
  System.out.println("timer fired!");
});
----

又比如收到一个HTTP请求：

[source,java]
----
server.requestHandler(request -> {
  // 服务器每次收到一个HTTP请求时这个处理器将被调用
  request.response().end("hello world!");
});
----

稍后当Vert.x有事件要传给您的处理器时，它会 *异步地* 调用这个处理器。

由此，下面会引入Vert.x中一些重要的概念。

== 不要阻塞我！

Vert.x中的几乎所有API都不会阻塞调用线程，除了个别特例（如以 "Sync" 结尾的某些文件系统操作）。

可以立即提供结果的API会立即返回，否则您需要提供一个处理器（`Handler`）
来接收稍后回调的事件。

因为Vert.x API不会阻塞线程，
所以通过Vert.x您可以只使用少量的线程来处理大量的并发。

当使用传统的阻塞式API做以下操作时，调用线程可能会被阻塞：

* 从 Socket 中读取数据
* 写数据到磁盘
* 发送消息给接收者并等待回复
* 其他很多情况

在上述情况下，线程在等待处理结果时它不能做任何事，此时这些线程并无实际用处。

这意味着如果使用阻塞式API处理大量并发，
需要大量线程来防止应用程序停止运转。

而这些线程使用的内存（例如它们的栈）和线程上下文切换开销很可观。

这意味着，阻塞式的方式对于现代应用程序所需要的并发级别来说是难于扩展的。

== Reactor 模式和 Multi-Reactor 模式

我们前边提过 Vert.x 的 API 都是事件驱动的，当有事件时 Vert.x 会将事件传给处理器来处理。

在多数情况下，Vert.x使用被称为 *Event Loop* 的线程来调用您的处理器。

由于Vert.x或应用程序的代码块中没有阻塞，**Event Loop**
可以在事件到达时快速地分发到不同的处理器中。

由于没有阻塞，Event Loop 可在短时间内分发大量的事件。
例如，一个单独的 *Event Loop* 可以非常迅速地处理数千个 HTTP 请求。

我们称之为 https://en.wikipedia.org/wiki/Reactor_pattern[Reactor 模式]（译者注：Reactor Pattern 翻译成了 https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F[反应器模式]）。

您之前也许听说过它，例如 Node.js 实现了这种模式。

在一个标准的Reactor实现中，有 *一个独立的 Event Loop* 会循环执行，
处理所有到达的事件并传递给处理器处理。

单一线程的问题在于它在任意时刻只能运行在一个核上，
如果您希望单线程反应器应用（如您的 Node.js 应用）扩展到多核服务器上，
则需要启动并且管理多个不同的进程。

Vert.x的工作方式有所不同。每个 `Vertx` 实例维护的是 *多个Event Loop 线程*。
默认情况下，我们会根据机器上可用的核数量来设置 Event Loop 的数量，您亦可自行设置。

这意味着 Vertx 进程能够在您的服务器上扩展，与 Node.js 不同。

我们将这种模式称为 *Multi-Reactor 模式*（多反应器模式），区别于单线程的 Reactor 模式（反应器模式）。

NOTE: 即使一个 `Vertx` 实例维护了多个 Event Loop，任何一个特定的处理器永远不会被并发执行。
大部分情况下（除了 <<worker_verticles, Worker Verticle>> 以外）
它们总是在同一个 Event Loop 线程中被调用。

[[golden_rule]]
== 黄金法则：不要阻塞Event Loop

尽管Vert.x 的 API 都是非阻塞式的，且不会阻塞 Event Loop，
但是用户编写的处理器中可能会阻塞 Event Loop。

如果这样做，该 Event Loop 在被阻塞时就不能做任何事情；如果您阻塞了 `Vertx`
实例中的所有Event Loop，那么您的应用就会完全停止！

所以不要这样做！*这是一个警告!*

这些阻塞做法包括：

* +Thead.sleep()+
* 等待一个锁
* 等待一个互斥信号或监视器（例如同步的代码块）
* 执行一个长时间数据库操作并等待其结果
* 执行一个复杂的计算，占用了可感知的时长
* 在循环语句中长时间逗留

如果上述任何一种情况停止了 Event Loop 并占用了 **显著执行时间** ，
那您应该去面壁（译者注：原文此处为 Naughy Step，英国父母会在家里选择一个角落作为小孩罚站或静坐的地方，被称为 naughty corner 或 naughty step），等待下一步的指示。

所以，什么是 *显著执行时间* ？

您要等多久？它取决于您的应用程序和所需的并发数量。

如果您只有单个 Event Loop，而且您希望每秒处理10000个 HTTP 请求，
很明显的是每一个请求处理时间不可以超过0.1毫秒，所以您不能阻塞任何过多（大于0.1毫秒）的时间。

*这个数学题并不难，将留给读者作为练习。*

如果您的应用程序没有响应，可能这是一个迹象，表明您在某个地方阻塞了Event Loop。
为了帮助您诊断类似问题，若 Vert.x 检测到 Event Loop 有一段时间没有响应，将会自动记录这种警告。
若您在日志中看到类似警告，那么您需要检查您的代码。比如：

----
Thread vertx-eventloop-thread-3 has been blocked for 20458 ms
----

Vert.x 还将提供堆栈跟踪，以精确定位发生阻塞的位置。

如果想关闭这些警告或更改设置，您可以在创建 `Vertx` 对象之前在
`link:../../apidocs/io/vertx/core/VertxOptions.html[VertxOptions]` 中完成此操作。

== Future的异步结果

Vert.x 4使用future承载异步结果。

异步的方法会返回一个 `link:../../apidocs/io/vertx/core/Future.html[Future]` 对象，其包含
_成功_ 或 _失败_ 的异步结果。

我们不能直接操作future的异步结果，而应该设置future的handler；
当future执行完毕，结果可用时，会调用handler进行处理。

[source,java]
----
FileSystem fs = vertx.fileSystem();

Future<FileProps> future = fs.props("/my_file.txt");

future.onComplete((AsyncResult<FileProps> ar) -> {
  if (ar.succeeded()) {
    FileProps props = ar.result();
    System.out.println("File size = " + props.size());
  } else {
    System.out.println("Failure: " + ar.cause().getMessage());
  }
});
----

NOTE: Vert.x 3的API只提供了回调模式；为了减少从Vert.x 3迁移到Vert.x 4的工作量，Vert.x 4为每个异步方法都保留了回调版本。
如上面样例代码的 `props` 方法，提供了带回调参数的版本
`link:../../apidocs/io/vertx/core/file/FileSystem.html#props-java.lang.String-io.vertx.core.Handler-[props]`

== Future组合

`link:../../apidocs/io/vertx/core/Future.html#compose-java.util.function.Function-[compose]` 方法作用于顺序组合 future：

- 若当前future成功，执行`compose`方法指定的方法，该方法返回新的future；当返回的新future完成时，future组合成功；
- 若当前future失败，则future组合失败。

[source,java]
----
FileSystem fs = vertx.fileSystem();

Future<Void> future = fs
  .createFile("/foo")
  .compose(v -> {
    // createFile文件创建完成后执行
    return fs.writeFile("/foo", Buffer.buffer());
  })
  .compose(v -> {
    // writeFile文件写入完成后执行
    return fs.move("/foo", "/bar");
  });
----

这里例子中，有三个操作被串起来了：

1. 一个文件被创建（`createFile`）
2. 一些东西被写入到文件（`writeFile`）
3. 文件被移走（`move`）

如果这三个步骤全部成功，则最终的 `Future`（`future`）会是成功的；
其中任何一步失败，则最终 `Future` 就是失败的。

除了上述方法， `link:../../apidocs/io/vertx/core/Future.html[Future]` 还提供了更多方法：`map`，`recover`，`otherwise`，以及 `flatMap` （等同 `compose` 方法）。

== Future协作

Vert.x 中的 `link:../../apidocs/io/vertx/core/Future.html[futures]` 支持协调多个Future，
支持并发组合（并行执行多个异步调用）和顺序组合
（依次执行异步调用）。

`link:../../apidocs/io/vertx/core/CompositeFuture.html#all-io.vertx.core.Future-io.vertx.core.Future-[CompositeFuture.all]` 方法接受多个 `Future` 对象作为参数（最多6个，或者传入 `List`）。
当所有的 `Future` 都成功完成，该方法将返回一个 _成功的_ `Future`；当任一个 `Future` 执行失败，则返回一个 _失败的_ `Future`：

[source,java]
----
Future<HttpServer> httpServerFuture = httpServer.listen();

Future<NetServer> netServerFuture = netServer.listen();

CompositeFuture.all(httpServerFuture, netServerFuture).onComplete(ar -> {
  if (ar.succeeded()) {
    // 所有服务器启动完成
  } else {
    // 有一个服务器启动失败
  }
});
----

所有被合并的 `Future` 中的操作同时运行。当组合的处理操作完成时，该方法返回的 `Future` 上绑定的处理器（`link:../../apidocs/io/vertx/core/Handler.html[Handler]`）会被调用。
只要有一个操作失败（其中的某一个 `Future` 的状态被标记成失败），
则返回的 `Future` 会被标记为失败。如果所有的操作都成功，
则返回的 `Future` 将会成功完成。

您可以传入一个 `Future` 列表（可能为空）：

[source,java]
----
CompositeFuture.all(Arrays.asList(future1, future2, future3));
----

`all` 方法的合并会 _等待_ 所有的 Future 成功执行（或任一失败），
而 `any` 方法的合并会 _等待_ 第一个成功执行的Future。`link:../../apidocs/io/vertx/core/CompositeFuture.html#any-io.vertx.core.Future-io.vertx.core.Future-[CompositeFuture.any]` 方法接受多个 `Future`
作为参数（最多6个，或传入 `List`）。当任意一个 `Future` 成功得到结果，则该 `Future` 成功；
当所有的 `Future` 都执行失败，则该 `Future` 失败。

[source,java]
----
CompositeFuture.any(future1, future2).onComplete(ar -> {
  if (ar.succeeded()) {
    // 至少一个成功
  } else {
    // 所有的都失败
  }
});
----

它也可使用 `Future` 列表传参：

[source,java]
----
CompositeFuture.any(Arrays.asList(f1, f2, f3));
----

`join` 方法的合并会 _等待_ 所有的 `Future` 完成，无论成败。
`link:../../apidocs/io/vertx/core/CompositeFuture.html#join-io.vertx.core.Future-io.vertx.core.Future-[CompositeFuture.join]` 方法接受多个 `Future` 作为参数（最多6个），并将结果归并成一个 `Future` 。
当全部 `Future` 成功执行完成，得到的 `Future` 是成功状态的；当至少一个 `Future` 执行失败时，
得到的 `Future` 是失败状态的。

[source,java]
----
CompositeFuture.join(future1, future2, future3).onComplete(ar -> {
  if (ar.succeeded()) {
    // 所有都成功
  } else {
    // 全部完成（无论成功还是失败），且至少一个失败
  }
});
----

它也可使用 `Future` 列表传参：

[source,java]
----
CompositeFuture.join(Arrays.asList(future1, future2, future3));
----

=== 兼容CompletionStage

JDK的 `CompletionStage` 接口用于组合异步操作，
Vert.x的 `Future` API可兼容`CompletionStage`。

我们可以用 `link:../../apidocs/io/vertx/core/Future.html#toCompletionStage--[toCompletionStage]` 方法将Vert.x的 `Future` 对象转为 `CompletionStage` 对象，如：

[source,java]
----
Future<String> future = vertx.createDnsClient().lookup("vertx.io");
future.toCompletionStage().whenComplete((ip, err) -> {
  if (err != null) {
    System.err.println("Could not resolve vertx.io");
    err.printStackTrace();
  } else {
    System.out.println("vertx.io => " + ip);
  }
});
----

相应地，可使用 `link:../../apidocs/io/vertx/core/Future.html#fromCompletionStage-java.util.concurrent.CompletionStage-[Future.fromCompletionStage]` 方法将 `CompletionStage` 对象转为Vert.x的 `Future` 对象。
`Future.fromCompletionStage` 有两个重载方法：

. 第一个重载方法只接收一个 `CompletionStage` 参数，会在执行 `CompletionStage` 实例的线程中调用 `Future` 的方法；
. 第二个重载方法额外多接收一个 `link:../../apidocs/io/vertx/core/Context.html[Context]` 参数，会在Vert.x的Context中调用 `Future` 的方法。

IMPORTANT: 由于Vert.x的 `Future` 通常会与Vert.x的代码、库以及客户端等一起使用，为了与Vert.x的线程模型更好地配合，
大部分场景下应使用`Future.fromCompletionStage(CompletionStage, Context)`方法。

下面的例子展示了如何将 `CompletionStage` 对象转为Vert.x的 `Future` 对象，这里选择使用Vert.x的Context执行:

[source,java]
----
Future.fromCompletionStage(completionStage, vertx.getOrCreateContext())
  .flatMap(str -> {
    String key = UUID.randomUUID().toString();
    return storeInDb(key, str);
  })
  .onSuccess(str -> {
    System.out.println("We have a result: " + str);
  })
  .onFailure(err -> {
    System.err.println("We have a problem");
    err.printStackTrace();
  });
----

== Verticles

Vert.x 通过开箱即用的方式提供了一个简单便捷的、可扩展的、类似 https://en.wikipedia.org/wiki/Actor_model[Actor Model] 的部署和并发模型机制。
您可以用此模型机制来保管您自己的代码组件。

*这个模型是可选的，Vert.x
并不强制使用这种方式创建应用程序。*

这个模型并不是严格的 Actor 模式实现，但它确实有相似之处，
特别是在并发、扩展性和部署等方面。

使用该模型，需要将应用代码编写成多个 *Verticle*。

Verticle 是由 Vert.x 部署和运行的代码块。默认情况一个 Vert.x 实例维护了N个 Event Loop
线程（默认情况下N = CPU核数 x 2）。Verticle 实例可使用任意 Vert.x 支持的编程语言编写，
而且一个简单的应用程序也可以包含多种语言编写的 Verticle。

您可以将 Verticle 想成 http://en.wikipedia.org/wiki/Actor_model[Actor Model] 中的 Actor。

一个应用程序通常是由在同一个 Vert.x 实例中同时运行的许多 Verticle 实例组合而成。
不同的 Verticle 实例通过向 <<event_bus, Event Bus>> 上发送消息来相互通信。

include::override/verticles.adoc[]

=== Verticle 种类

这儿有两种 Verticle：

Standard Verticles:: 这是最常用的一类 Verticle —— 它们永远运行在 Event Loop 线程上。
更多讨论详见稍后的章节。
Worker Verticles:: 这类 Verticle 会运行在 Worker Pool 中的线程上。
一个实例绝对不会被多个线程同时执行。

=== Standard verticles

当 Standard Verticle 被创建时，它会被分派给一个 Event Loop 线程，并在这个 Event Loop 中执行它的 `start` 方法。
当您在一个 Event Loop 上调用了 Core API 中的方法并传入了处理器时，Vert.x
将保证用与调用该方法时相同的 Event Loop 来执行这些处理器。

这意味着我们可以保证您的 Verticle 实例中 *所有的代码都是在相同Event Loop中执行*
（只要您不创建自己的线程来调用它！）

同样意味着您可以将您的应用中的所有代码用单线程方式编写，让 Vert.x
去考虑线程和扩展问题。您不用再考虑 synchronized 和 volatile 的问题，
也可以避免传统的多线程应用经常会遇到的竞态条件和死锁的问题。

[[worker_verticles]]
=== Worker verticles

Worker Verticle 和 Standard Verticle 很像，但它并不是由一个 Event Loop 来执行，
而是由Vert.x中的 Worker Pool 中的线程执行。

Worker Verticle 设计用于调用阻塞式代码，它不会阻塞任何 Event Loop。

如果您不想使用 Worker Verticle 来运行阻塞式代码，
您还可以在一个Event Loop中直接使用 <<blocking_code, 内联阻塞式代码>>

您需要通过 `link:../../apidocs/io/vertx/core/DeploymentOptions.html#setWorker-boolean-[setWorker]` 方法来将 Verticle 部署成一个 Worker Verticle：

[source,java]
----
DeploymentOptions options = new DeploymentOptions().setWorker(true);
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);
----

在 Vert.x 中，Worker Verticle 实例绝对不会同时被多个线程执行，
但它可以在不同时间由不同线程执行。

=== 编程方式部署Verticle

部署Verticle可以使用任意一个 `link:../../apidocs/io/vertx/core/Vertx.html#deployVerticle-io.vertx.core.Verticle-[deployVerticle]` 方法，
并传入一个 Verticle名称或Verticle 实例。

NOTE: 通过 Verticle *实例* 来部署 Verticle 仅限Java语言。

[source,java]
----
Verticle myVerticle = new MyVerticle();
vertx.deployVerticle(myVerticle);
----

您同样可以指定 Verticle 的 *名称* 来部署它。

这个 Verticle 的名称会用于查找实例化 Verticle的特定
`link:../../apidocs/io/vertx/core/spi/VerticleFactory.html[VerticleFactory]`。

不同的 Verticle Factory 可用于实例化不同语言的 Verticle，也可用于其他目的，
例如加载服务、运行时从Maven中获取Verticle实例等。

因此可以部署任何使用Vert.x支持的语言编写的Verticle。

下面的例子展示了如何部署多个不同语言编写的 Verticle ：

[source,java]
----
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle");

// 部署JavaScript的Verticle
vertx.deployVerticle("verticles/myverticle.js");

// 部署Ruby的Verticle
vertx.deployVerticle("verticles/my_verticle.rb");
----

=== Verticle名称到Factory的映射规则

使用名称部署Verticle时，会通过名称来选择一个用于实例化 Verticle
的 Verticle Factory。

Verticle 名称可以增加一个以冒号结尾的前缀，这个前缀用于查找Factory，如：

----
js:foo.js // 使用JavaScript的Factory
groovy:com.mycompany.SomeGroovyCompiledVerticle // 用Groovy的Factory
service:com.mycompany:myorderservice // 用Service的Factory
----

如果不指定前缀，Vert.x将根据Verticle名称的后缀来查找对应Factory，如：

----
foo.js // 将使用JavaScript的Factory
SomeScript.groovy // 将使用Groovy的Factory
----

若前缀后缀都没指定，Vert.x将假定Verticle名称是一个Java 全限定类名（FQCN），
并尝试实例化它。

=== 如何定位Verticle Factory？

大部分Verticle Factory会从 classpath 中加载，并在 Vert.x 启动时注册。

您同样可以使用编程的方式去注册或注销Verticle Factory：通过 `link:../../apidocs/io/vertx/core/Vertx.html#registerVerticleFactory-io.vertx.core.spi.VerticleFactory-[registerVerticleFactory]` 方法和
`link:../../apidocs/io/vertx/core/Vertx.html#unregisterVerticleFactory-io.vertx.core.spi.VerticleFactory-[unregisterVerticleFactory]` 方法。

=== 等待部署完成

Verticle是异步部署的，换而言之，可能在 `deploy` 方法调用返回后一段时间才会完成部署。

如果您想要在部署完成时收到通知，则可以指定一个完成处理器：

[source,java]
----
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", res -> {
  if (res.succeeded()) {
    System.out.println("Deployment id is: " + res.result());
  } else {
    System.out.println("Deployment failed!");
  }
});
----

如果部署成功，这个完成处理器的结果中将会包含部署ID的字符串。

这个部署ID可以用于撤销部署。

=== 撤销Verticle

我们可以通过 `link:../../apidocs/io/vertx/core/Vertx.html#undeploy-java.lang.String-[undeploy]` 方法来撤销部署好的 Verticle。

撤销操作也是异步的，因此若您想要在撤销完成后收到通知，则可以指定另一个完成处理器：

[source,java]
----
vertx.undeploy(deploymentID, res -> {
  if (res.succeeded()) {
    System.out.println("Undeployed ok");
  } else {
    System.out.println("Undeploy failed!");
  }
});
----

=== 设置 Verticle 实例数量

使用名称部署 Verticle 时，可以指定需要部署的 Verticle
实例的数量。

[source,java]
----
DeploymentOptions options = new DeploymentOptions().setInstances(16);
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);
----

这个功能对于跨多核扩展时很有用。例如，您有一个带Web服务的Verticle需要部署在多核的机器上，
您可以部署多个实例来利用所有的核。

include::override/verticle-configuration.adoc[]

=== 高可用性

Verticle可以启用高可用方式（HA）部署。在这种方式下，当其中一个部署在
Vert.x 实例中的 Verticle 突然挂掉，这个 Verticle 可以在集群环境中的另一个 Vert.x 实例中重新部署。

若要启用高可用方式运行一个 Verticle，仅需要追加 `-ha` 参数：

[source]
----
vertx run my-verticle.js -ha
----

当启用高可用方式时，不需要追加 `-cluster` 参数。

关于高可用的功能和配置的更多细节可参考
<<high_avalibability_and_fail_over, 高可用和故障转移>>


=== 从命令行运行Verticle

您可以在 Maven 或 Gradle 项目中以正常方式添加 Vert.x
Core 为依赖，在项目中直接使用 Vert.x。

您也可以从命令行直接运行 Vert.x 的 Verticle。

为此，您需要下载并安装 Vert.x 的发行版，并且将安装的 `bin` 目录添加到您的
`PATH` 环境变量中，并确保您的 `PATH` 中设置了Java 8的JDK环境。

NOTE: 在 `PATH` 设置JDK是为了支持Java代码的运行时编译（on the fly compilation）。

现在您可以使用 `vertx run` 命令运行Verticle了，下面是一些例子：

----
# 运行JavaScript的Verticle
vertx run my_verticle.js

# 运行Ruby的Verticle
vertx run a_n_other_verticle.rb

# 使用集群模式运行Groovy的Verticle
vertx run FooVerticle.groovy -cluster
----

您甚至可以不必编译 Java 源代码，直接运行它：

----
vertx run SomeJavaSourceFile.java
----

Vert.x 在运行Java 源代码文件之前将执行运行时编译，
这对于快速原型制作和演示很有用，而且不需要配置 Maven 或 Gradle 就能跑起来！

欲了解有关在命令行执行 `vertx` 可用的各种选项完整信息，
可以直接在命令行键入 `vertx` 查看帮助。

=== 退出 Vert.x 环境

Vert.x 实例维护的线程不是守护线程，因此它们会阻止JVM退出。

如果您通过嵌入式的方式使用 Vert.x 并且完成了操作，您可以调用 `link:../../apidocs/io/vertx/core/Vertx.html#close--[close]`
方法关闭它。

这将关闭所有内部线程池并关闭其他资源，允许JVM退出。

=== Context 对象

当 Vert.x 传递一个事件给处理器或者调用 `link:../../apidocs/io/vertx/core/Verticle.html[Verticle]` 的 start 或 stop 方法时，
它会关联一个 `Context` 对象来执行。通常来说这个context会是一个
**event-loop context**，它绑定到了一个特定的 Event Loop 线程上。所以在该context上执行的操作总是
在同一个 Event Loop 线程中。对于运行内联的阻塞代码的 Worker Verticle 来说，会关联一个
Worker Context，并且所有的操作运都会运行在 Worker 线程池的线程上。（译者注：每个 `Verticle` 在部署的时候都会被分配一个 `Context`（根据配置不同，可以是Event Loop Context 或者 Worker Context），之后此 `Verticle` 上所有的普通代码都会在此 `Context` 上执行（即对应的 Event Loop 或Worker 线程）。一个 `Context` 对应一个 Event Loop 线程（或 Worker 线程），但一个 Event Loop 可能对应多个 `Context`。）

您可以通过 `link:../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--[getOrCreateContext]` 方法获取 `Context` 实例：

[source, java]
----
Context context = vertx.getOrCreateContext();
----

若已经有一个context和当前线程关联，那么它直接重用这个context对象，
如果没有则创建一个新的。您可以检查获取的context的 _类型_ ：

[source, java]
----
Context context = vertx.getOrCreateContext();
if (context.isEventLoopContext()) {
  System.out.println("Context attached to Event Loop");
} else if (context.isWorkerContext()) {
  System.out.println("Context attached to Worker Thread");
} else if (! Context.isOnVertxThread()) {
  System.out.println("Context not attached to a thread managed by vert.x");
}
----

当您获取了这个context对象，您就可以在context中异步执行代码了。换句话说，
您提交的任务将会在同一个context中运行：

[source, java]
----
vertx.getOrCreateContext().runOnContext( (v) -> {
  System.out.println("This will be executed asynchronously in the same context");
});
----

当在同一个context中运行了多个处理函数时，可能需要在它们之间共享数据。
context对象提供了存储和读取共享数据的方法。举例来说，它允许您将数据传递到
 `link:../../apidocs/io/vertx/core/Context.html#runOnContext-io.vertx.core.Handler-[runOnContext]` 方法运行的某些操作中：

[source, java]
----
final Context context = vertx.getOrCreateContext();
context.put("data", "hello");
context.runOnContext((v) -> {
  String hello = context.get("data");
});
----

您还可以通过 `link:../../apidocs/io/vertx/core/Context.html#config--[config]`
方法访问 Verticle 的配置信息。查看 <<passing_configuration_to_a_verticle, 向 Verticle 传入配置>> 章节了解更多配置信息。

=== 执行周期性/延迟性操作

在 Vert.x 中，延迟执行或定期执行操作很常见。

在 Standard Verticle 中您不能直接让线程休眠以引入延迟，因为它会阻塞 Event Loop 线程。

取而代之是使用 Vert.x 定时器。定时器可以是 *一次性* 或 *周期性* 的，两者我们都会讨论到。

==== 一次性计时器

一次性计时器会在一定延迟后调用一个 Event Handler，以毫秒为单位计时。

您可以通过 `link:../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-[setTimer]` 方法传递延迟时间和一个处理器来设置计时器的触发。

[source,java]
----
long timerID = vertx.setTimer(1000, id -> {
  System.out.println("And one second later this is printed");
});

System.out.println("First this is printed");
----

返回值是一个唯一的计时器id，该id可用于之后取消该计时器，这个计时器id会传入给处理器。

==== 周期性计时器

您同样可以使用 `link:../../apidocs/io/vertx/core/Vertx.html#setPeriodic-long-io.vertx.core.Handler-[setPeriodic]` 方法设置一个周期性触发的计时器。

第一次触发之前同样会有一段设置的延时时间。

`setPeriodic` 方法的返回值也是一个唯一的计时器id，若之后该计时器需要取消则使用该id。

传给处理器的参数也是这个唯一的计时器id。

请记住这个计时器将会定期触发。如果您的定时任务会花费大量的时间，则您的计时器事件可能会连续执行,
甚至发生更坏的情况：重叠。

这种情况，您应考虑使用 `link:../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-[setTimer]` 方法，
当任务执行完成时设置下一个计时器。

[source,java]
----
long timerID = vertx.setPeriodic(1000, id -> {
  System.out.println("And every second this is printed");
});

System.out.println("First this is printed");
----

==== 取消计时器

指定一个计时器id并调用 `link:../../apidocs/io/vertx/core/Vertx.html#cancelTimer-long-[cancelTimer]` 方法来取消一个周期性计时器。如：

[source,java]
----
vertx.cancelTimer(timerID);
----

==== Verticle 中自动清除定时器

如果您在 Verticle 中创建了计时器，
当这个 Verticle 被撤销时这个计时器会被自动关闭。

=== Verticle worker pool

Verticle 使用 Vert.x 中的 Worker Pool 来执行阻塞式行为，例如 `link:../../apidocs/io/vertx/core/Context.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-[executeBlocking]` 或
Worker Verticle。

可以在部署配置项中指定不同的 Worker 线程池：

[source,java]
----
vertx.deployVerticle("the-verticle", new DeploymentOptions().setWorkerPoolName("the-specific-pool"));
----

[[event_bus]]
include::eventbus.adoc[]

include::override/json.adoc[]

include::json-pointers.adoc[]

include::buffers.adoc[]

include::net.adoc[]

include::http.adoc[]

include::shareddata.adoc[]

include::filesystem.adoc[]

include::datagrams.adoc[]

include::dns.adoc[]

[[streams]]
include::streams.adoc[]

include::parsetools.adoc[]

== 线程安全

大多数Vert.x 对象可以从不同的线程安全地访问， _然而_
在相同的上下文中访问它们时，性能才是最优的。

例如，若您部署了一个创建了 `link:../../apidocs/io/vertx/core/net/NetServer.html[NetServer]` 的Verticle，该 `NetServer` 在处理器中提供了
`link:../../apidocs/io/vertx/core/net/NetSocket.html[NetSocket]` 实例，
则最好始终从该Verticle的Event Loop中访问Socket 实例。

如您已经遵守了标准的Vert.x Verticle部署模型，并注意避免在 Verticle 之间分享对象，
那这种情况您无需考虑。

[[blocking_code]]
== 运行阻塞式代码

在一个完美的世界中，不存在战争和饥饿，所有的API都将使用异步方式编写，
兔兔和小羊羔将会在阳光明媚的绿色草地上手牵手地跳舞。

*但是……真实世界并非如此（您最近看新闻了吧？）*

事实是很多库含有同步的API（如果不是多数的库的话，尤其JVM生态中的库），这些API中许多方法都是阻塞式的。
一个很好的例子就是 JDBC API，它本质上是同步的，无论多么努力地去尝试，Vert.x
都不能像魔法小精灵撒尘变法一样将它转换成异步API。

我们不会将所有的内容重写成异步方式，所以我们为您提供一种在
Vert.x 应用中安全调用"传统"阻塞API的方法。

如之前讨论，您不能在 Event Loop 中直接调用阻塞式操作，因为这样做会阻止 Event Loop 
执行其他有用的任务。那您该怎么做？

可以通过调用 `link:../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-[executeBlocking]`
方法来指定阻塞式代码的执行以及阻塞式代码执行后处理结果的异步回调。

[source,java]
----
vertx.executeBlocking(promise -> {
  // 调用阻塞的、需要消耗显著执行时间的API
  String result = someAPI.blockingMethod("hello");
  promise.complete(result);
}, res -> {
  System.out.println("The result is: " + res.result());
});
----

WARNING: 阻塞式代码应该仅仅在合理的时间内阻塞（例如不超过几秒钟）。
长时间阻塞的操作或者轮询操作（例如一个线程以阻塞的方式不断的循环轮询事件）都应该避免。
当一个阻塞的操作持续超过10秒，blocked thread checker将会在控制台上打印一条消息。
长时间阻塞的操作应该由程序使用一个专用的线程管理，
他需要能够使用event-bus 或 `link:../../apidocs/io/vertx/core/Context.html#runOnContext-io.vertx.core.Handler-[runOnContext]` 与verticles交互


默认情况下，如果 `executeBlocking` 在同一个上下文环境中（如：同一个 Verticle 实例）被调用了多次，
那么这些不同的 `executeBlocking` 代码块会 _顺序执行_（一个接一个）。

若您不关心您调用 `link:../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-[executeBlocking]` 的顺序，
可以将 `ordered` 参数的值设为 `false`。这样任何 `executeBlocking`
都会在 Worker Pool 中并行执行。

另外一种运行阻塞式代码的方式是使用 <<worker_verticles, worker verticle>>。

一个 Worker Verticle 始终会使用 Worker Pool 中的某个线程来执行。

默认情况下，阻塞式代码会在 Vert.x 的 Worker Pool 中执行，通过 `link:../../apidocs/io/vertx/core/VertxOptions.html#setWorkerPoolSize-int-[setWorkerPoolSize]` 配置。

可以为不同的用途创建不同的池（pool）：

[source,java]
----
WorkerExecutor executor = vertx.createSharedWorkerExecutor("my-worker-pool");
executor.executeBlocking(promise -> {
  // 调用阻塞的、需要消耗显著执行时间的API
  String result = someAPI.blockingMethod("hello");
  promise.complete(result);
}, res -> {
  System.out.println("The result is: " + res.result());
});
----

Worker Executor 在不需要的时候必须被关闭：

[source,java]
----
executor.close();
----

当使用同一个名字创建了许多 worker 时，它们将共享同一个 pool。
当所有的 worker executor 调用了 `close` 方法被关闭过后，对应的 worker pool 会被销毁。

如果 Worker Executor 在 Verticle 中创建，那么 Verticle 实例销毁的同时 Vert.x
将会自动关闭这个 Worker Executor。

Worker Executor 可以在创建的时候配置：

[source,java]
----
int poolSize = 10;

// 2分钟
long maxExecuteTime = 2;
TimeUnit maxExecuteTimeUnit = TimeUnit.MINUTES;

WorkerExecutor executor = vertx.createSharedWorkerExecutor("my-worker-pool", poolSize, maxExecuteTime, maxExecuteTimeUnit);
----

NOTE: 这些配置信息在 worker pool 创建的时候设置。

== Metrics SPI

默认情况下，Vert.x不会记录任何指标。相反，它提供了一个SPI，其他人可以将它的实现类添加到类路径中。
指标SPI是一项高级特性，允许实现类可以从Vert.x捕获事件以收集指标。
有关详细信息，请参阅
`link:../../apidocs/io/vertx/core/spi/metrics/VertxMetrics.html[API 文档]` 。

若使用 `link:../../apidocs/io/vertx/core/metrics/MetricsOptions.html#setFactory-io.vertx.core.spi.VertxMetricsFactory-[setFactory]` 嵌入了Vert.x实例，
也可以用编程方式指定一个指标工厂。

== "vertx" 命令行

`vertx` 命令用于在命令行中与 Vert.x 进行交互。主要用于运行 Vert.x Verticle。
为此，您需要下载并安装Vert.x 发行版，并将安装位置的 `bin` 目录添加
到 `PATH` 环境变量中，还要确保您的 `PATH` 上已配置了Java 8的JDK的路径。

NOTE: `PATH` 中的JDK是用于支持Java代码的快速编译。

=== 运行 Verticles

您可以使用 `vertx run` 从命令行直接运行Vert.x 的 Verticle，以下是
`run` _命令_ 的几个示例：

[source]
----
vertx run my-verticle.js                                 (1)
vertx run my-verticle.groovy                             (2)
vertx run my-verticle.rb                                 (3)

vertx run io.vertx.example.MyVerticle                    (4)
vertx run io.vertx.example.MVerticle -cp my-verticle.jar (5)

vertx run MyVerticle.java                                (6)
----
1. 部署一个JavaScript的Verticle
2. 部署一个Groovy的Verticle
3. 部署一个Ruby的Verticle
4. 部署一个已经编译好的Java的Verticle，类的根路径是当前目录
5. 部署一个已经打包成jar的Verticle，这个jar需要在类路径中
6. 编译Java源代码并进行部署

正如您在Java中可看到的，该Verticle的名称可以是class文件的全限定类名，
也可以指定Java 源文件，Vert.x会为你编译它。

您可以在Verticle的名称前添加其他语言名称作为前缀来进行部署。例如：
若某个Verticle是Groovy编译的类，您可以使用语言前缀 `groovy:` ，让Vert.x 知道它是一个Groovy 类而不是Java 类。

[source]
----
vertx run groovy:io.vertx.example.MyGroovyVerticle
----

`vertx run` 命令可以使用几个可选参数，它们是：

* `-options <options>` - 提供Vert.x选项。
`options` 是一个包含描述Vert.x选项的json文件的名称。该参数是可选的。
* `-conf <config>` - 提供了Verticle的一些配置，
`config` 是一个包含描述Verticle配置的JSON文件的名称。该参数是可选的。
* `-cp <path>` - 搜索Verticle和它使用的其他任何资源的路径，
默认为 `.`（当前目录）。若您的Verticle引用了其他脚本、类或其他资源
（例如jar文件），请确保这些资源存在此路径上。该路径可以包含多个路径条目，
由 `:` （冒号）或 `;` （分号）进行分割——这取决于操作系统。每个路径条目可以是包含脚本的目录的绝对路径或相对路径，
也可以是jar或zip文件的绝对或相对文件名。
一个示例路径可能是 `-cp classes:lib/otherscripts:jars/myjar.jar:jars/otherjar.jar` 。
始终使用路径引用您的Verticle需要的任何资源，**不要** 将它们放在系统类路径上，
因为这会导致部署的Verticle之间的隔离问题。
* `-instances <instances>`  - 要实例化的Verticle实例的数目，每个Verticle实例都是严格单线程（运行）的，
因此为了在可用的cpu核心上扩展您的应用程序，您可能需要部署多个实例。
若省略，则部署单个实例。
* `-worker` - 此选项可确定一个Verticle是否为Worker Verticle。
* `-cluster` -  此选项确定Vert.x实例是否尝试与网络上的其他Vert.x实例形成集群，
集群Vert.x实例允许Vert.x与其他节点构建一个分布式Event Bus。
默认为false（非集群模式）。
* `-cluster-port` - 若指定了 `cluster` 选项，
则可以确定哪个端口将用于与其他Vert.x实例进行集群通信。默认为 `0` ——这意味着“ _选择一个空闲的随机端口_ ”。
您通常不需要指定此参数，除非您需要绑定特定端口。
* `-cluster-host` - 若指定了 `cluster` 选项，则可以确定哪个主机地址将用于与其他Vert.x实例进行集群通信。
若没有设置，集群的eventbus会尝试绑定到同一个host作为底层集群管理。
作为最后的手段，
将会在可用网路接口中选取其中一个。
* `-cluster-public-port` - 若指定了 `cluster` 选项，则可以确定哪个端口将被公布用于与其他Vert.x实例进行集群通信。
默认值是 `-1` ，表示与 `cluster-port` 保持一致。
* `-cluster-public-host` - 若指定了 `cluster` 选项，则可以确定哪个主机地址将被公布用于与其他Vert.x实例进行集群通信。
如果没有指定，则默认使用 `cluster-host` 的值
* `-ha` - 若指定，该Verticle将部署为（支持）高可用性（HA）。
有关详细信息，请参阅相关章节。
* `-quorum` - 该参数需要和 `-ha` 一起使用，它指定集群中所有 _HA deploymentIDs_ 
处于活动状态的最小节点数，默认为0。
* `-hagroup` - 该参数需要和 `-ha` 一起使用，它指定此节点将加入的HA组。
集群中可以有多个HA组，节点只会故障转移到同一组中的其他节点。默认为
`+++__DEFAULT__+++`。

您还可以使用下边方式设置系统属性：`-Dkey=value`。

下面有更多的例子：

使用默认设置运行JavaScript的Verticle：server.js：
[source]
----
vertx run server.js
----

运行指定类路径的预编译好的10个Java Verticle实例
[source]
----
vertx run com.acme.MyVerticle -cp "classes:lib/myjar.jar" -instances 10
----

通过 _源文件_ 运行10个Java Verticle的实例
[source]
----
vertx run MyVerticle.java -instances 10
----

运行20个Ruby语言的Worker Verticle实例
[source]
----
vertx run order_worker.rb -instances 20 -worker
----

在同一台计算机上运行两个JavaScript Verticle，
并让它们彼此以及在网络上的其他任何服务器构建一个集群：
[source]
----
vertx run handler.js -cluster
vertx run sender.js -cluster
----

运行一个Ruby Verticle并传入一些配置：
[source]
----
vertx run my_verticle.rb -conf my_verticle.conf
----
其中 `my_verticle.conf` 也许会包含以下配置：

[source, json]
----
{
"name": "foo",
"num_widgets": 46
}
----

该配置可通过Core API在Verticle内部可用。

当使用Vert.x的高可用功能时，您可能需要创建一个Vert.x的 _裸_ 实例。
此实例在启动时不会部署任何Verticle，但如果集群中的另一个节点消失，则会在此节点运行之前消失的实例。
如需要创建一个 _裸_ 实例，执行以下命令：

[source]
----
vertx bare
----

根据您的集群配置，您可能需要添加 `cluster-host` 和 `cluster-port` 参数。

=== 执行打包成 fat-jar 的Vert.x 应用

_fat jar_ 是一个嵌入了所有依赖的可执行的jar，这意味着您不必在执行jar的机器上预先安装Vert.x。
它像任何可执行的Java jar一样可直接执行：

[source]
----
java -jar my-application-fat.jar
----

对于这点，Vert.x 没什么特别的，您可以使用任何Java应用程序。

您可以创建自己的主类并在 MANIFEST 中指定，但建议您将代码编写成Verticle，
并使用Vert.x中的  `link:../../apidocs/io/vertx/core/Launcher.html[Launcher]` 类 (`io.vertx.core.Launcher`) 作为您的主类。
这也是使用命令行运行Vert.x时使用的主类，因此允许您指定命令行参数，
如 `-instances` 以便更轻松地扩展应用程序。

要将您的Verticle全部部署在这个 _fat-jar_ 中时，您必须将下边信息写入 _manifest_ ：

* `Main-Class` 设置为 `io.vertx.core.Launcher`
* `Main-Verticle` 指定要运行的Main Verticle（Java完全限定类名或脚本文件名）

您还可以提供您将传递给 `vertx run` 的常用命令行参数：
[source]
----
java -jar my-verticle-fat.jar -cluster -conf myconf.json
java -jar my-verticle-fat.jar -cluster -conf myconf.json -cp path/to/dir/conf/cluster_xml
----

NOTE: 请参阅官方 Vert.x Examples 仓库中的 Maven/Gradle 相应示例来了解如何将应用打包成fat-jar。

通过 fat jar 运行应用时，默认会执行 `run` 命令。

=== 显示Vert.x的版本

若想显示Vert.x的版本，只需执行：

[source]
----
vertx version
----

=== 其他命令

除了 `run` 和 `version` 以外，`vertx` 命令行和 `Launcher` 还提供了其他 _命令_ ：

您可以使用下边命令创建一个 `bare` 实例：

[source]
----
vertx bare
# or
java -jar my-verticle-fat.jar bare
----

您还可以在后台启动应用程序：

[source]
----
java -jar my-verticle-fat.jar start --vertx-id=my-app-name
----

若 `my-app-name` 未设置，将生成一个随机的id，并在命令提示符中打印。您可以将 `run`
选项传递给 `start` 命令：

[source]
----
java -jar my-verticle-fat.jar start —-vertx-id=my-app-name -cluster
----

一旦在后台启动，可以使用 `stop` 命令停止它：

[source]
----
java -jar my-verticle-fat.jar stop my-app-name
----

您还可以使用以下方式列出后台启动的Vert.x应用程序：

[source]
----
java -jar my-verticle-fat.jar list
----

`vertx` 工具也可以使用 `start` 、 `stop` 和 `list` 命令，`start` 命令支持以下几个选项：

* `vertx-id` ：应用程序ID，若未设置，则使用随机UUID
* `java-opts` ：Java虚拟机选项，若未设置，则使用 `JAVA_OPTS` 环境变量
* `redirect-output` ：重定向生成的进程输出和错误流到父进程流

若选项值包含空白，则需使用 `""` （双引号）将选项值括起来。

由于 `start` 命令产生一个新的进程，传递给JVM的java选项不会被传播，所以您 **必须** 
使用 `java-opts` 来配置JVM（`-X`， `-D`...）。若您使用 `CLASSPATH` 环境变量，
请确保路径下包含所有需要的jar（vertx-core、您的jar和所有依赖项）。

该命令集是可扩展的，请参考 <<Extending the vert.x Launcher, 扩展 Vert.x 启动器>> 章节。

=== 实时重部署

在开发时，可以方便在文件更改时实时重新部署应用程序。`vertx` 
命令行工具和更普遍的 `link:../../apidocs/io/vertx/core/Launcher.html[Launcher]` 类提供了这个功能。
这里有些例子：

[source]
----
vertx run MyVerticle.groovy --redeploy="**/*.groovy" --launcher-class=io.vertx.core.Launcher
vertx run MyVerticle.groovy --redeploy="**/*.groovy,**/*.rb"  --launcher-class=io.vertx.core.Launcher
java io.vertx.core.Launcher run org.acme.MyVerticle --redeploy="**/*.class"  --launcher-class=io.vertx.core
.Launcher -cp ...
----

重新部署的过程执行如下。首先，您的应用程序作为后台应用程序启动
（使用 `start` 命令）。当发现文件更改时，该进程将停止并重新启动该应用。
这样可避免泄露。

要启用实时重新部署，请将 `--redeploy` 选项传递给 `run` 命令。`--redeploy` 表示要
_监视_ 的文件集，这个集合可使用 Ant样式模式（使用 `\**`，`*` 和 `?`），
您也可以使用逗号（`,`）分隔它们来指定多个集合。文件路径都是相对于当前工作目录。

传递给 `run` 命令的参数最终会传递给应用程序，可使用 `--java-opts` 配置JVM虚拟机选项。
例如，如果想传入一个 `conf` 参数或是系统属性，
您可以使用 `--java-opts="-conf=my-conf.json -Dkey=value"`。

`--launcher-class` 选项确定应用程序的 _主类_ 启动器。它通常是
`link:../../apidocs/io/vertx/core/Launcher.html[Launcher]` ，但您也可以使用您自己的 _主类_ 。

也可以在IDE中使用重部署功能：

* Eclipse - 创建一个 _Run_ 配置，使用 `io.vertx.core.Launcher` 类作为 _主类_ 。在 _Program Arguments_ 
区域（ _Arguments_ 选项卡中），写入 `run your-verticle-fully-qualified-name --redeploy=*/*.java 
--launcher-class=io.vertx.core.Launcher` ，您还可以添加其他参数。随着 Eclipse
在保存时增量编译您的文件，重部署工作会顺利进行。
* IntelliJ - 创建一个 _Run_ 配置（_Application_）,将主类设置为 `io.vertx.core.Launcher`。在
程序参数中写：`run your-verticle-fully-qualified-name --redeploy=*/*.class 
--launcher-class=io.vertx.core.Launcher` 。要触发重新部署，您需要显式 _构造_
项目或模块（_Build_ -> _Make project_）。

要调试应用程序，请将运行配置创建为远程应用程序，
并使用 `--java-opts` 配置调试器。每次重新部署后，请勿忘记重新插入(re-plug)调试器，
因为它每次都会创建一个新进程。

您还可以在重新部署周期中挂接（hook）构建过程：

[source]
----
java -jar target/my-fat-jar.jar --redeploy="**/*.java" --on-redeploy="mvn package"
java -jar build/libs/my-fat-jar.jar --redeploy="src/**/*.java" --on-redeploy='./gradlew shadowJar'
----

"on-redeploy"选项指定在应用程序关闭后和重新启动之前调用的命令。
因此，如果构建工具更新了某些运行时构件，则可以将其挂接。例如，您可以启动 `gulp`
或 `grunt` 来更新您的资源。如果需要传递参数到你的应用程序中，不要忘记将
`--java-opts` 添加到命令参数里：

[source]
----
java -jar target/my-fat-jar.jar --redeploy="**/*.java" --on-redeploy="mvn package" --java-opts="-Dkey=val"
java -jar build/libs/my-fat-jar.jar --redeploy="src/**/*.java" --on-redeploy='./gradlew shadowJar' --java-opts="-Dkey=val"
----

重新部署功能还支持以下设置：

* `redeploy-scan-period` ：文件系统检查周期（以毫秒为单位），默认为250ms
* `redeploy-grace-period` ：在2次重新部署之间等待的时间（以毫秒为单位），默认为1000ms
* `redeploy-termination-period` ：停止应用程序后等待的时间
（在启动用户命令之前）。这个在Windows上非常有用，因为这个进程并没立即被杀死。
时间以毫秒为单位，默认0ms

== 集群管理器

在 Vert.x 中，集群管理器可用于各种功能，包括：

* 集群中 Vert.x 节点的发现和分组
* 维护集群范围中的主题订阅者列表（所以我们可知道哪些节点对哪个Event Bus地址感兴趣）
* 分布式Map的支持
* 分布式锁
* 分布式计数器

集群管理器 _不_ 处理Event Bus节点之间的传输，这由 Vert.x 直接通过TCP连接完成。

Vert.x发行版中使用的默认集群管理器是使用的  http://hazelcast.com[Hazelcast] 集群管理器，
但是它可以简单被替换成其他实现类，因为Vert.x集群管理器可插拔的。

集群管理器必须实现 `link:../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html[ClusterManager]` 接口，
Vert.x在运行时使用Java的服务加载器
https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[Service Loader]
功能在类路径中查找 `link:../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html[ClusterManager]` 的实例，从而定位集群管理器。

若您在命令行中使用Vert.x并要使用集群，则应确保Vert.x安装路径的 `lib`
目录包含您的集群管理器的jar包。

若您在 Maven/Gradle 项目使用Vert.x，则只需将集群管理器jar作为依赖添加到你的项目中。

您也可以以编程的方式在嵌入Vert.x 时使用
`link:../../apidocs/io/vertx/core/VertxOptions.html#setClusterManager-io.vertx.core.spi.cluster.ClusterManager-[setClusterManager]` 指定集群管理器。

== 日志记录

Vert.x使用内置的日志API进行记录日志，并支持各种日志记录后端。

日志后端选择如下：

. 后端由设置的 `vertx.logger-delegate-factory-class-name` 系统属性表示，或者是
. 当在类路径下存在 `vertx-default-jul-logging.properties` 文件时，则使用JDK logging，或者是
. 类路径中存在以下实现，按照以下优先顺序进行选择：
.. SLF4J
.. Log4J
.. Log4J2

除此之外，Vert.x默认使用JDK日志记录

=== 通过系统属性配置

设置 系统属性 `vertx.logger-delegate-factory-class-name` 的值为：

* `io.vertx.core.logging.SLF4JLogDelegateFactory`，则使用SLF4J，
* `io.vertx.core.logging.Log4j2LogDelegateFactory`，则使用Log4J2，
* `io.vertx.core.logging.JULLogDelegateFactory`，则使用JDK日志记录

=== 自动配置

当没有设置系统属性 `vertx.logger-delegate-factory-class-name` 的值时，
Vert.x会尝试查找最合适的日志框架：

* 当类路径下有SLF4J实现类时，则使用SLF4J，例如 `LoggerFactory.getILoggerFactory()` 返回值不是 `NOPLoggerFactory` 实例，
* 否则，当classpath有Log4j2实现类时，则使用Log4j2
* 除此之外，使用JUL

=== 配置JUL日志记录

JUL日志配置文件可以使用普通的JUL方式指定 —— 通过设置系统属性 `java.util.logging.config.file` 的值为您的配置文件。
更多关于此部分以及JUL配置文件结构的内容，请参阅`JUL`日志记录的文档。

Vert.x还提供了一种更方便的方式指定配置文件，无需设置系统属性。
您只需在您的类路径中提供名为 `vertx-default-jul-logging.properties` 的JUL配置文件（例如在您的fatjar中），Vert.x将使用该配置文件配置JUL。

[[netty-logging]]
=== Netty 日志记录

Netty并不依赖外部的日志配置（例如，系统属性）。
相反，它基于Netty类可见的日志库实现日志记录配置：

* 使用 `SLF4J` 库，如果它可见，
* 否则使用 `Log4j` ，如果它可见，
* 否则使用 `Log4j2` ，如果它可见，
* 否则使用默认的 `java.util.logging`

NOTE: 你们锐利的眼光可能已经注意到Vert.x遵循相同的优先级顺序

使用 `io.netty.util.internal.logging.InternalLoggerFactory` 可以直接强制设置日志实现类。

[source,java]
----
// 将日志实现强制设为 Log4j 2
InternalLoggerFactory.setDefaultFactory(Log4J2LoggerFactory.INSTANCE);
----

=== 故障排除

==== SLF4J启动警告

若您在启动应用程序时看到以下信息：

----
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
----

这意味着您的类路径中有 SLF4J-API 却没绑定到具体的实例类中。使用SLF4J记录的消息将会丢失。
您应该添加具体的实现到你的类路径下。参考 https://www.slf4j.org/manual.html#swapping 选择具体实现并配置。

请注意，Netty会寻找SLF4-API的jar，并在默认情况下使用它。

==== 对等连接重置

若您的日志显示一堆：

----
io.vertx.core.net.impl.ConnectionBase
SEVERE: java.io.IOException: Connection reset by peer
----

这意味着客户端正在重置HTTP连接，而不是关闭它。
此消息还可能表示您没有读取完整的有效负荷（连接在读取完全之前被切断）。（译者注：通常情况下，这是正常的，无需担心，如果您打开浏览器，按快捷键不停地刷新页面，就能看到该SEVERE日志。）

include::override/hostname-resolution.adoc[]

[[high_avalibability_and_fail_over]]
== 高可用与故障转移

Vert.x 可以支持 verticle 运行于高可用（HA）模式。这种模式之下，
如果一个 vert.x 实例所运行的 verticle 突然宕掉，该 verticle 将会被迁移到其他的 vert.x 实例中
（该 vert.x 实例必须处于同一个集群之中）。

=== 自动故障转移

当运行 vert.x 时开启了高可用（_HA_）选项，此时如果某个 vert.x 实例中的某个 verticle 运行失败或者宕掉，
该 verticle 将会被自动重新部署于集群中的另一个 vert.x 实例中。我们把这种机制称为 _verticle故障转移_。

只要在运行 vert.x 的命令行中追加 `-ha` 参数，就可以开启 _高可用_ 模式：

[source]
----
vertx run my-verticle.js -ha
----

要让高可用机制起作用，您需要在集群中开启至少2个 Vert.x 实例，
现在假设您已经在集群中运行了一个 Vert.x 实例，例如：

[source]
----
vertx run my-other-verticle.js -ha
----

此时如果运行 `my-verticle.js` 的 Vert.x 实例宕掉了（例如您可以使用 `kill -9` 命令强行杀掉这个进程来模拟此场景），
运行 `my-other-verticle.js` 的 Vert.x 实例会自动地部署 `my-verticle.js` ，
此时该 Vert.x 实例同时运行了这两个 verticle （my-other-verticle.js 和 my-verticle.js）。

NOTE: 如果要使得这种迁移机制起作用，则必须保证第二个 vert.x 实例可以访问到该 verticle 对应的文件
（在此场景中指的是 `my-verticle.js`）。

IMPORTANT: 请注意，通过正常方式退出的 Vert.x 实例不会触发故障转移操作
（例如使用 `CTRL-C` 组合键或者 `kill -SIGINT` 命令）。

您也可以启动若干个 Vert.x _裸_ 实例————指的是它们在启动时没有加载任何 verticle，此时，
它们一样可以对集群中的其他节点起到故障转移的作用。启动一个空白的 Vert.x 实例很简单，只需要执行以下命令：

[source]
----
vertx run -ha
----

当使用 `-ha` 参数时， 可以不需要再追加 `-cluster` 参数，
因为高可用模式是假定了您需要运行在集群模式之下的。

NOTE: 依据您的集群配置选项，您可能还是需要自定义集群管理器
（默认使用 Hazelcast），以及追加集群主机（`cluster-host`）和集群端口（`cluster-port`）等参数。

=== 高可用组

当 Vert.x 实例运行于高可用模式时，您还可以对其进行高可用分组，这里称之为 _高可用组_ 。
此处的高可用组指的是一个集群之中的节点的一种逻辑分组，被分配了高可用组的节点只会对同一个高可用组之下的其他节点执行故障转移操作。
如果没有指定高可用组，系统会自动将节点分配到默认的 `+++__DEFAULT__+++` 高可用组。

在运行 verticle 时可以使用 `-hagroup` 参数指定高可用分组，例如：

[source]
----
vertx run my-verticle.js -ha -hagroup my-group
----

举个例子：

在第一个终端里运行：

[source]
----
vertx run my-verticle.js -ha -hagroup g1
----

在第二个终端里，我们以同一个高可用组运行另一个 verticle：

[source]
----
vertx run my-other-verticle.js -ha -hagroup g1
----

最后，在第三个终端里，我们以不同的高可用组再运行一个其他的 verticle：

[source]
----
vertx run yet-another-verticle.js -ha -hagroup g2
----

如果我们杀掉第一个终端里的实例，这里面的 verticle 将会通过故障转移机制迁移到第二个终端里的实例中，
而不是第三个终端里的实例中，因为第三个终端里的实例被分配了不同的高可用组。

如果杀掉第三个终端里的实例，则不会发生故障转移操作，
因为此终端里的 vert.x 实例被分配了不同的高可用组。

=== 处理网络分区 - Quora

高可用实现也支持 `quora` （一种多数派机制）。在分布式系统中， Quorum 是指一种投票机制，在这种投票机制之下，
某个分布式事务只有获得不少于指定投票数量的票数，才允许执行某个操作。

启动 Vert.x 实例的时候，您可以将其设置成在进行高可用（HA）部署之前需要一个 `quorum` 。
在这个语境之下， `quorum` 指的是集群中某个特定的分组内的节点数量的下限。
典型的例如您将 `quorum` 的数值设置为 `1 + N/2` （现在以 Q 指代该数值，其中的 N 代表分组中的节点总数），
那么如果集群中少于 `Q` 个节点的情况下，该高可用（HA）部署将被取消，待到节点数量达到这个 Q 数值的时候，会再次进行部署。
这种机制可以防止出现网络分区（亦称 _脑裂_）。

关于 `quora` 的更多信息请参考 http://en.wikipedia.org/wiki/Quorum_(distributed_computing)[这里] 。

要在运行 vert.x 实例的时候启用 `quorum` ，您只需要在命令行中指定 `-quorum` 参数，例如

在第一个终端中执行：
[source]
----
vertx run my-verticle.js -ha -quorum 3
----

此时 Vert.x 实例将会启动，但是并不会部署这个模块，因为现在只有1个节点，
而不是3个。

在第二个终端中执行：
[source]
----
vertx run my-other-verticle.js -ha -quorum 3
----

此时 Vert.x 实例将会启动，但是并不会部署这个模块，因为现在只有2个节点，
而不是3个。

在第三个终端中，您可以启动另一个 vert.x 实例：

[source]
----
vertx run yet-another-verticle.js -ha -quorum 3
----

哇！————我们有了3个节点，这正是 `quorum` 的数值。
此时此刻这些模块将会被自动地部署到所有实例上。

如果我们关闭或者强行杀死其中一个节点，那么这些模块将会被自动卸载，
因为节点数量已经不满足 `quorum` 数值条件。

Quora 也可以和高可用分组联合使用，此时 quora 
仅在指定的分组中起作用。

== 本地传输

在BSD（OSX）和Linux操作系统中运行 Vert.x 的时候，如果条件允许，可以启用 http://netty.io/wiki/native-transports.html[native transports] 这种特性：

include::override/configuring-native.adoc[]

=== Linux 下的本地传输

您需要在classpath中加入以下依赖：

[source,xml]
----
<dependency>
 <groupId>io.netty</groupId>
 <artifactId>netty-transport-native-epoll</artifactId>
 <classifier>linux-x86_64</classifier>
 <!--<version>Should align with netty version that Vert.x uses</version>-->
</dependency>
----

Linux下的本地传输可以设置更多的网络选项：

* `SO_REUSEPORT`
* `TCP_QUICKACK`
* `TCP_CORK`
* `TCP_FASTOPEN`

[source,java]
----
vertx.createHttpServer(new HttpServerOptions()
  .setTcpFastOpen(fastOpen)
  .setTcpCork(cork)
  .setTcpQuickAck(quickAck)
  .setReusePort(reusePort)
);
----

=== BSD 下的本地传输

您需要在classpath中加入以下依赖：

[source,xml]
----
<dependency>
 <groupId>io.netty</groupId>
 <artifactId>netty-transport-native-kqueue</artifactId>
 <classifier>osx-x86_64</classifier>
 <!--<version>必须和 Vert.x 所使用的 netty 的版本一致</version>-->
</dependency>
----

MacOS 中，Sierra及以上的版本支持这种特性。

BSD 下的本地传输可以启用以下额外的网络选项：

* `SO_REUSEPORT`

[source,java]
----
vertx.createHttpServer(new HttpServerOptions().setReusePort(reusePort));
----

=== 域套接字

通过本地传输，网络服务可以使用域套接字：

[source,java]
----
vertx.createNetServer().connectHandler(so -> {
  // 处理请求
}).listen(SocketAddress.domainSocketAddress("/var/tmp/myservice.sock"));
----

http服务示例：

[source,java]
----
vertx.createHttpServer().requestHandler(req -> {
  // 处理请求
}).listen(SocketAddress.domainSocketAddress("/var/tmp/myservice.sock"), ar -> {
  if (ar.succeeded()) {
    // 绑定到 socket
  } else {
    ar.cause().printStackTrace();
  }
});
----

也适用于网络客户端：

[source,java]
----
NetClient netClient = vertx.createNetClient();

// 仅在 Linux 和 BSD 中可以使用
SocketAddress addr = SocketAddress.domainSocketAddress("/var/tmp/myservice.sock");

// 连接到服务器
netClient.connect(addr, ar -> {
  if (ar.succeeded()) {
    // 连接成功
  } else {
    ar.cause().printStackTrace();
  }
});
----

http客户端示例：

[source,java]
----
HttpClient httpClient = vertx.createHttpClient();

// 仅在 Linux 和 BSD 中可以使用
SocketAddress addr = SocketAddress.domainSocketAddress("/var/tmp/myservice.sock");

// 向服务器发送请求
httpClient.request(new RequestOptions()
  .setServer(addr)
  .setHost("localhost")
  .setPort(8080)
  .setURI("/"))
  .onSuccess(request -> {
    request.send().onComplete(response -> {
      // 处理响应信息
    });
  });
----

== 安全提示

Vert.x 是一套工具集，而不是一种强迫人们使用指定方式行事的框架，对于开发者而言，
这赋予了你们强大的力量，但也使得你们必须负起不小的责任。

与任何一种工具集一样，写出不安全的程序是难以避免的，所以您在开发程序时需要时刻小心，
特别是这个程序是暴露于毫无保护的公共场合（例如互联网）的情况下。

=== Web 应用

如果要编写一个 web 应用程序，这里强烈建议您使用 Vert.x-Web
来实现资源服务和文件上传功能，而不是直接使用 Vert.x core 。

Vert.x-Web 会对请求路径进行规整化，这可以阻止那些不怀好意的人利用精心构建的特殊URL，
来访问web应用根目录之外的资源的企图。

在文件上传方面也是如此， Vert.x-Web 不会完全信赖客户所端提供的文件名，因为客户端有可能精心设置一个特殊的文件名，
使得上传的文件被保存到磁盘上某个意料之外的位置上。 Vert.x-Web 可以保证上传的文件是被存放到磁盘上确切可知道位置的。

Vert.x core没有这样的检查，您需要自己实现。

=== 集群模式事件总线流量

在网络上使用集群模式的事件总线连接不同的 Vert.x 节点时，总线里的流量是未经加密的，
因此，若您的 Vert.x 节点处于不可信任的网络之上，则应该避免使用这种方式向这样的 Vert.x 节点发送信息。

=== 安全方面的标准最佳实践

任何服务都可能存在潜在的漏洞，无论是使用 Vert.x 还是任何其他工具包来进行编写，
因此始终应该遵循安全最佳实践，特别是当您的服务面向公众时。

例如，您应该始终在DMZ（隔离区）中运行它们，并使用权限受限的用户账户，
以确保服务被渗透以后只会遭受有限的破坏。

== Vert.x 命令行界面（CLI）API

include::cli.adoc[]

== Vert.x 启动器（Launcher）

Vert.x `link:../../apidocs/io/vertx/core/Launcher.html[Launcher]` 在 _fat-jar_ 中作为主类，由 `vertx` 命令行程序调用。
它可执行一组 _命令_ ，如 _run_ 、 _bare_ 和 _start_ 等

=== 扩展 Vert.x 启动器（Launcher）

您可以通过实现自己的 `link:../../apidocs/io/vertx/core/spi/launcher/Command.html[Command]` 类来扩展命令集（仅限于Java）：

[source, java]
----
@Name("my-command")
@Summary("A simple hello command.")
public class MyCommand extends DefaultCommand {

 private String name;

 @Option(longName = "name", required = true)
 public void setName(String n) {
   this.name = n;
 }

 @Override
 public void run() throws CLIException {
   System.out.println("Hello " + name);
 }
}
----

您还需要实现一个 `link:../../apidocs/io/vertx/core/spi/launcher/CommandFactory.html[CommandFactory]`：

[source, java]
----
public class HelloCommandFactory extends DefaultCommandFactory<HelloCommand> {
 public HelloCommandFactory() {
  super(HelloCommand.class);
 }
}
----

然后创建 `src/main/resources/META-INF/services/io.vertx.core.spi.launcher.CommandFactory`
并且添加一行表示工厂类的完全限定名称：

----
io.vertx.core.launcher.example.HelloCommandFactory
----

构建包含命令的jar。确保包含了SPI文件
(`META-INF/services/io.vertx.core.spi.launcher.CommandFactory`)。

然后，将包含该命令的jar放入fat-jar（或包含在其中）的类路径中，或放在Vert.x发行版的 `lib`
目录中，您将可以执行：

[source]
----
vertx hello vert.x
java -jar my-fat-jar.jar hello vert.x
----

=== 在 fat-jar 中使用启动器（Launcher）

要在 _fat-jar_ 中使用 `link:../../apidocs/io/vertx/core/Launcher.html[Launcher]` 类，只需要将 _MANIFEST_ 的 `Main-Class` 设置为
`io.vertx.core.Launcher`。另外，将 _MANIFEST_ 中 `Main-Verticle` 条目设置为您的Main Verticle的名称。

默认情况下，它会执行 `run` 命令。但是，您可以通过设置 _MANIFEST_ 的 `Main-Command` 条目来配置默认命令。
若在没有命令的情况下启动 _fat-jar_ 会使用默认命令。

=== 启动器（Launcher）子类

您还可以创建 `link:../../apidocs/io/vertx/core/Launcher.html[Launcher]`的子类来启动您的应用程序。
这个类设计得易于扩展。

一个启动器 `link:../../apidocs/io/vertx/core/Launcher.html[Launcher]` 的子类可以：

* 在 `link:../../apidocs/io/vertx/core/Launcher.html#beforeStartingVertx-io.vertx.core.VertxOptions-[beforeStartingVertx]` 中自定义 Vert.x 配置
*  通过重写 `link:../../apidocs/io/vertx/core/Launcher.html#afterStartingVertx-io.vertx.core.Vertx-[afterStartingVertx]`
来检索由“run”或“bare”命令创建的Vert.x实例
* 使用
`link:../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getMainVerticle--[getMainVerticle]` 和
`link:../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getDefaultCommand--[getDefaultCommand]` 方法配置默认的Verticle和命令
* 使用 `link:../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#register-java.lang.Class-[register]`
和 `link:../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#unregister-java.lang.String-[unregister]` 方法添加/删除命令

=== 启动器（Launcher）和退出代码

当您使用 `link:../../apidocs/io/vertx/core/Launcher.html[Launcher]` 类作为主类时，它的退出码有以下取值：

* `0` :进程顺利结束，或抛出未捕获的错误；
* `1` :用于通用错误；
* `11`:Vert.x无法初始化；
* `12`:生成的进程无法启动、发现或停止，该错误代码一般由 `start` 和 
`stop` 命令使用；
* `14`:系统配置不符合系统要求（如找不到 `java` 命令）；
* `15`:主Verticle不能被部署；

== 配置 Vert.x 缓存

当 Vert.x 需要从类路径中读取文件（嵌入在 fat-jar 中，在classpath中jar文件或classpath中其他文件）时，
它会把文件复制到缓存目录。背后原因很简单：
从 jar 或从输入流读取文件是阻塞的。所以为了避免每次都付出损耗，
Vert.x 会将文件复制到其缓存目录中，并随后读取该文件。也可以配置此行为。

首先，默认情况下，Vert.x 使用 `$CWD/.vertx` 作为缓存目录，它在此目录创建一个唯一的目录，
以避免冲突。可以使用 `vertx.cacheDirBase` 系统属性配置该位置。
如，若当前工作目录不可写（例如在不可变容器中），
请使用以下命令启动应用程序：

[source]
----
vertx run my.Verticle -Dvertx.cacheDirBase=/tmp/vertx-cache
# or
java -jar my-fat.jar vertx.cacheDirBase=/tmp/vertx-cache
----

IMPORTANT: 该目录必须是 **可写的** 。

当您编辑资源（如HTML、CSS或JavaScript）时，这种缓存机制可能令人讨厌，因为它仅仅提供文件的第一个版本
（因此，如果您想重新加载页面，不会显示到您的编辑改变）。要避免此情况，
请使用 `-Dvertx.disableFileCaching=true` 启动应用程序。使用此设置，Vert.x 仍然使用缓存，
但会始终读取原文件然后刷新在缓存中的版本。
因此，如果您编辑从类路径提供的文件并刷新浏览器，Vert.x 会从类路径读取它，将其复制到缓存目录并从中提供。
不要在生产环境使用这个设置，它很有可能影响性能。

最后，您可以使用 `-Dvertx.disableFileCPResolving=true` 完全禁用缓存。
这个设置的副作用是：Vert.x将无法从类路径中读取任何文件（仅从文件系统中读取）。
使用此设置时要非常小心。
